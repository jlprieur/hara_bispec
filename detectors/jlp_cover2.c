/********************************************************************
* Set of routines for uv-coverage, spectral and bispectral lists:
*  
* Contains:
* covera, cover, affect,
* bispec3
* correct_photon_noise
*
* JLP
* Version 24-08-93
*******************************************************************/
#include <stdio.h>
#include <math.h>
#include <jlp_ftoc.h>

/*
#define DEBUG
*/

/*
#define IRMAX25
*/

#ifdef IRMAX25
#define IRMAX 25
#define NBMAX 980
#define NGMAX 187566
#define NBC_DIM 51 
#define NBC_OFFSET 26 
#else
#define IRMAX 30 
#define NBMAX 1410 
#define NGMAX 388400 
#define NBC_DIM 61 
#define NBC_OFFSET 31 
#endif
/*
#define NBC_DIM (2 * IRMAX+1) 
#define NBC_OFFSET (IRMAX+1) 
*/

int bispec3(double *re, double *im, float *modsq, float *snrm, INT4 *nx, 
            INT4 *ny, float *yce1, INT4 *ir, INT4 *nbeta, INT4 *ngamma);

static int *nbcouv, *ixy_1, *ixy_2, *ngt, *klm;
static float xr[NBMAX], xi[NBMAX]; 
static int couv(INT4 *ir, INT4 *nbeta, INT4 *ngamma);
static int affect(int isx, int isy, int irs, INT4 *nb, INT4 *ng);

/********************************************************************
* Subroutine COVERA
* To compute the elements of the uv coverage, and of the A matrix
* (To solve the equation A*X=Y, i.e., to invert the bispectral relations)
*
* Output:
* IR: Maximum radius of the uv-coverage
* NBETA: Number of elements of the spectral list (Number of columns of A)
* NGAMMA: Number of elements of the bispectral list (Number of rows of A)
*
*********************************************************************/
int COVERA(ir,nbeta,ngamma)
int *ir, *nbeta, *ngamma;
{
int isize;
register int i;
 
/* bncouv( x from -IRMAX to IRMAX,  y from 0 to IRMAX ) */
/* ixy( 1 for x; 2 for y,  nb from 0 to NBMAX ) */
isize = (2 * IRMAX + 1) * NBC_DIM * sizeof(int);
JLP_GVMI(&nbcouv,&isize);
isize = (NBMAX + 1) * sizeof(int);
JLP_GVMI(&ixy_1,&isize);
JLP_GVMI(&ixy_2,&isize);
JLP_GVMI(&ngt,&isize);
isize = 3 * NGMAX * sizeof(int);
JLP_GVMI(&klm,&isize);

for(i = 0; i < NBC_DIM * (2 * IRMAX + 1); i++) nbcouv[i] = 0;
 
/*
	COMMON /C1/NBCOUV(MIRMAX:IRMAX,NULL:IRMAX),IXY(2,NULL:NBMAX)
	COMMON /C5/NGT(NBMAX)
C KLM(1,.) for K ; KLM(2,.) for L ; KLM(3,.) for M ;
        COMMON /C2/KLM(3,NGMAX)

*/
 
/* Computing the A matrix as generated by the uv-coverage 
   (defined only by IR for a full pupil) */
couv(ir,nbeta,ngamma);
 
printf(" covera/uv-coverage, IR = %d \n",*ir);
printf("  NBETA (spectral list) = %d \n",*nbeta);
printf("  NGAMMA (bispec. list) = %d \n",*ngamma);
 
/* Computing the number of closure relations for some values of NB: */
for ( i = 3; i < (*nbeta) + 1 ; i += 100)
  {
   printf(" NB = %d  Closure relations: %d \n",i,ngt[i] - ngt[i - 1]);
  }
 
return(0);
}
/*******************************************************************
* COUV defines the uv-coverage and the A matrix:
* Input:
* IR: maximum radius of the uv-coverage
*
* Output:
* NBETA, NGAMMA: number of elements of the spectral and bispectral lists
*
* In common blocks (output): the uv-coverage is accessible from 2 sides:
*
* NBCOUV(I,J): uv-coverage (i.e. number of the spectral list for
*              the pixel(I,J) of the spectrum (I=0,J=0 for null frequency)
*
* IXY(1,I) and IXY(2,I) coordinates of the pixel number I in the spectral list
*              (this allows another entry for the uv-coverage)
*
*************************************************************************/
static int couv(INT4 *ir, INT4 *nbeta, INT4 *ngamma)
{
/* 
* nb: beta index, i.e. spectral list index
* ng: gamma index, i.e. bispectral list index
*/
int ir2max, nb, ng;
int i, i2, j2, ii2, irs;
register int j, ir2;
 
 
/* Easy cases: */
/* First spectral value at (0,0) */
 nb = 0;
 ixy_1[nb] = 0; ixy_2[nb] = 0;
 nbcouv[0 + NBC_OFFSET + NBC_DIM * 0] = nb;
 
/* Second spectral value at (1,0) */
 nb = 1;
 ixy_1[nb] = 1; ixy_2[nb] = 0;
 nbcouv[1 + NBC_OFFSET + NBC_DIM * 0] = nb;

/* Third spectral value at (0,1) */
 nb = 2;
 ixy_1[nb] = 0; ixy_2[nb] = 1;
 nbcouv[0 + NBC_OFFSET + NBC_DIM * 1] = nb;
 
/* Reseting the total number of elements the  bispectral list */
 ng = 0;
 
/* Main loop: work with successive iterations on circles with
* increasing radii.
* Squared radius: IR2 = 2, 3, ... ,IR2MAX
*/
ir2max = *ir * *ir;
for ( ir2 = 2; ir2 <= ir2max; ir2++) 
  {
/* Searching for the couples (I,J) such as: I**2 + J**2 = IR2 with I>=J */
    for ( j = 0; j <= *ir; j++) 
      {
       j2 = j*j; 
       i2 = ir2 - j2;
       if ( i2 < j2) break;
         i = (int)sqrt((double)i2);
         ii2 = i * i;
/* Selecting the points defined by each couple (i,j) 
   such that (i*i + j*j= ir2): */
         if(ii2 == i2)
            {
              irs = (int)sqrt((double)ir2);
              affect(i,j,irs,&nb,&ng);
/* Now use the symmetry relations: */
              if( i != j) 
                 affect(j,i,irs,&nb,&ng);
              if( j != 0) 
                 affect(-j,i,irs,&nb,&ng);
              if( i != j && j != 0) 
                 affect(-i,j,irs,&nb,&ng);
            }
      }
  }
 
/* NBETA: Total number of the spectral list (Number of columns of the X matrix)
* NGAMMA: Total number of the bispectral list (Number of rows of the X matrix)
* (Remember, we have to solve    A*X = Y) */
  *nbeta = nb;
  *ngamma = ng;

  return(0);
}
/*******************************************************************
* AFFECT:
* Gives a structure to the S group of the A matrix
* Input:
* ISX, ISY : coordinates
* IRS: radius
*
* Output:
* NB: index in the spectral list
* NG: index in the bispectral list
********************************************************************/
static int affect(int isx, int isy, int irs, INT4 *nb, INT4 *ng)
{ 
int nbs, nbk, nbr, itx, ity;
register int nbq, iklm;

/* Recording the new point of the uv coverage (spectral list): */
 (*nb)++;
 ixy_1[*nb] = isx; ixy_2[*nb] = isy;
 nbcouv[isx + NBC_OFFSET + NBC_DIM * isy] = *nb;

/* Searching for the couples associated with the point NBS=NB
* Generating the rows of the A matrix:
*/
 nbs = *nb;
 
/* Loop on all the possible points (Q): */
 iklm = 3 * (*ng);
 for( nbq = 1; nbq < nbs; nbq++)
  { 
/* Coordinates of the vector T = S - Q */
   itx = isx - ixy_1[nbq];
   ity = isy - ixy_2[nbq];
 
/* Work within the circle of radius IRS, so we can a priori reject
* the points outside the window [-IRS,+IRS]:
*/
   if(itx >= -irs && itx <= irs && ity >= -irs && ity <= irs)
      {
       if(ity > 0 || ( ity == 0 && itx >= 0))
          {
/* Case number 1 (which could be : k=t, l=q, k+l=s) */

            nbk = nbcouv[ itx + NBC_OFFSET + ity * NBC_DIM];
 
/* We select this couple (U,V) if the vector NBK is in [0,NBQ] */
            if( nbk != 0 && nbk <= nbq)
              {
              klm[iklm] = nbk; 
              iklm++;
              klm[iklm] = nbq; 
              iklm++;
              klm[iklm] = nbs;
              iklm++;
              (*ng)++;
              }
          }
      else
          { 
/* Case number 2 (which could be : r=-t, s=s, r+s=m=q) */
        nbr = nbcouv[ -itx + NBC_OFFSET - ity * NBC_DIM];
/* We select this couple (R,S) if the vector NBR is in [0,NBS] */
            if( nbr != 0 && nbr <= nbs)
              {
              klm[iklm] = nbr; 
              iklm++;
              klm[iklm] = nbs; 
              iklm++;
              klm[iklm] = nbq;
              iklm++;
              (*ng)++;
              }
/* Nota: we can only have L=NBS or M=NBS (never K=NBS) */
          }
      } 

/* End of loop on nbq */
}
 
/* NGT(NB) is the number of the last U,V couple of the group NB=NBS=S: */
   ngt[nbs] = *ng;

 return(0);
}

/*********************************************************************
* BISPEC1
* Same as BISPEC2, but older version, and sum of full bispectrum terms.
* (amplitude and phase)
* Reads a spectrum from an real image (from observations)
*
* Computes the bispectrum and spectrum lists from RE and IM
* already computed before calling this routine.
*
* Integrates the squared modulus of the spectrum and
* the phase factor of the bispectrum. Corrects from photon noise effects.
*
* Photon noise correction (cf JOSA 2, 14, Wirnitzer):
* (When spectrum normalized to one in the center)
* <i(u)>**2 = E(D...)/N**2 - 1/N
*
* <i(3)(u,v)> = E(D(3)(u,v)/N**3 - E(D(2)(u)/N**2)/N - E(D(2)(v)... +2/N**3)
*
* Input:
* RE(NX,NY)
* IM(NX,NY)
*
* Output:
* MODSQ: Sum of the modulus squared
* YCE1: phase factor of the bispectrum (real and imaginary)
* YCE1(.,3): sum of square real parts of the bispectrum
* YCE1(.,4): sum of square imaginary parts of the bispectrum
********************************************************************/
int bispec1(re,im,modsq,snrm,nx,ny,idim,yce1,ir,nbeta,ngamma)

float re[], im[], modsq[], snrm[], yce1[];
long *nx, *ny, *idim, *ir, *nbeta, *ngamma;
{
float w1, w2, xphot1, work;
int ii, jj, k1, k2, k3, iix, iiy;
float wr1, wr2, wr3, wi1, wi2, wi3;
float aar, aai, work1, work2; 
register int ng, i, j, nb, yce_ng, iklm;

#ifdef DEBUG
printf(" bispec1/ ir = %d nbeta = %d ngamma = %d\n",*ir, *nbeta, *ngamma);
#endif

/* Check the FFT (zero frequency is at (1,1)): */
xphot1 = re[0]*re[0] + im[0]*im[0];
xphot1 = sqrt((double)xphot1);

#ifdef DEBUG
printf(" xphot1 = %f \n",xphot1);
#endif
 
/* Normalization (necessary for photon noise correction): */
  for(j = 0; j < *ny; j++)
    for(i = 0; i < *nx; i++)
       {
       ii = i + j * *idim;
       re[ii] /= xphot1;
       im[ii] /= xphot1;
       }
 
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list. 
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       iix = ((ixy_1[nb] + *nx) % *nx); 
       iiy = ((ixy_2[nb] + *ny) % *ny); 
       ii = iix + iiy * *idim;
       xr[nb] = re[ii];
       xi[nb] = im[ii];
     }
 
/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* and correction from photon noise effects:
*/
  w2 = 2./(xphot1 * xphot1);
yce_ng = 0;
iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
     wr1 = xr[k1]; wr2 = xr[k2]; wr3 = xr[k3];
     wi1 = xi[k1]; wi2 = xi[k2]; wi3 = xi[k3];
/*  CC1=XC1*XC2*CONJG(XC3): AAR*WR3+AAI*WI3 */
     aar = wr1 * wr2 - wi1 * wi2;
     aai = wr2 * wi1 + wr1 * wi2;
     work1 = aar * wr3 + aai * wi3;
     work2 = aai * wr3 - aar * wi3;
/* CC1=XC1*XC2*CONJG(XC3)-XC1*CONJG(XC1)-XC2*CONJG(XC2)-XC3*CONJG(XC3)
* With photon noise correction:
*/
     work1 += - (wr1 * wr1 + wr2 * wr2 + wr3 * wr3 
              + wi1 * wi1 + wi2 * wi2 + wi3 * wi3) / xphot1 + w2;
     yce1[yce_ng] += work1;
     yce_ng++;
     yce1[yce_ng] += work2;

/* Estimation of the noise with the sum of squares: */
     yce_ng++;
     yce1[yce_ng] += work1*work1;
     yce_ng++;
     yce1[yce_ng] += work2*work2;
     yce_ng++;
  }
 
/****************************************************************/
/* Squared modulus for the output (corrected from photon noise) */
  w1 = 1. / xphot1;
  for( j = 0; j < *ny; j++)
    {
    jj = j * *idim;
    for( i = 0; i < *nx; i++)
       {
        ii = i + jj;
        work = re[ii]*re[ii] + im[ii]*im[ii];
/* Photon noise correction: */
        work = work - w1;
        modsq[ii] += work;
        snrm[ii] += work * work;
       }
    }
 
 return(0);
}
/*********************************************************************
* bispec3 
* Same as bispec1, but newer version.
* Sum of full bispectrum terms (amplitude and phase)
* Reads a spectrum from an real image (from observations)
*
* Computes the bispectrum and spectrum lists from RE and IM
* already computed before calling this routine.
*
* Integrates the squared modulus of the spectrum and
* the phase factor of the bispectrum. Corrects from photon noise effects.
*
* Photon noise correction (cf JOSA 2, 14, Wirnitzer):
* (When spectrum normalized to one in the center)
* <i(u)>**2 = E(D...)/N**2 - 1/N
*
* <i(3)(u,v)> = E(D(3)(u,v)/N**3 - E(D(2)(u)/N**2)/N - E(D(2)(v)... +2/N**3)
*
* Input:
* RE(NX,NY) (please note that idim has disappeared...)
* IM(NX,NY)
*
* Output:
* MODSQ: Sum of the modulus squared
* YCE1: phase factor of the bispectrum (real and imaginary)
* YCE1(.,3): sum of square real parts of the bispectrum
* YCE1(.,4): sum of square imaginary parts of the bispectrum
********************************************************************/
int bispec3(double *re, double *im, float *modsq, float *snrm, INT4 *nx, 
            INT4 *ny, float *yce1, INT4 *ir, INT4 *nbeta, INT4 *ngamma)
{
int k1, k2, k3;
float w1, wr1, wr2, wr3, wi1, wi2, wi3;
float aar, aai, work1, work2; 
register int ng, i, nb, yce_ng, iklm;

#ifdef DEBUG
/* Check the FFT (zero frequency is at (1,1)): */
w1 = re[0]*re[0] + im[0]*im[0];
w1 = sqrt((double)w1);
printf(" xphot1 = %f \n",w1);
#endif
 
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list. 
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       i = ((ixy_1[nb] + *nx) % *nx) 
           + (*nx * ((ixy_2[nb] + *ny) % *ny)); 
       xr[nb] = re[i];
       xi[nb] = im[i];
     }
 
/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* and correction from photon noise effects:
*/
yce_ng = 0;
iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
     wr1 = xr[k1]; wr2 = xr[k2]; wr3 = xr[k3];
     wi1 = xi[k1]; wi2 = xi[k2]; wi3 = xi[k3];
/*  CC1=XC1*XC2*CONJG(XC3): AAR*WR3+AAI*WI3 */
     aar = wr1 * wr2 - wi1 * wi2;
     aai = wr2 * wi1 + wr1 * wi2;
     work1 = aar * wr3 + aai * wi3;
     work2 = aai * wr3 - aar * wi3;
     yce1[yce_ng] += work1;
     yce_ng++;
     yce1[yce_ng] += work2;

/* Estimation of the noise with the sum of squares: */
     yce_ng++;
     yce1[yce_ng] += work1*work1;
     yce_ng++;
     yce1[yce_ng] += work2*work2;
     yce_ng++;
  }
 
/****************************************************************/
/* Squared modulus for the output (not corrected for photon noise) */
    for( i = 0; i < *nx * *ny; i++)
       {
        w1 = re[i]*re[i] + im[i]*im[i];
        modsq[i] += w1;
        snrm[i] += (w1 * w1);
       }
 
 return(0);
}
/**************************************************************** 
* Photon noise correction:
*
*  Input:
* modsq[]: mean normalized squared modulus
* xphot: mean photon flux per frame 
*
*****************************************************************/
int photon_corr(float *yce1, float *modsq, float *snrm, INT4 *nx, INT4 *ny,
                float *xphot, INT4 *nbeta, INT4 *ngamma, 
                INT4 *photon_correction)
{
float xphot2, xphot3, xphot4, xphot6;
float norm_fft, norm_fft2, norm_fft3, norm_fft4, norm_fft6;
float w2, work1;
int k1, k2, k3, iix, iiy;
register int i, nb, ng, yce_ng, iklm;

norm_fft = sqrt((double)(*nx * *ny));
norm_fft2 = *nx * *ny;
norm_fft3 = norm_fft2 * norm_fft;
norm_fft4 = norm_fft2 * norm_fft2;
norm_fft6 = norm_fft3 * norm_fft3;

/* Normalizes FFT (for compatibility with FFT_2D instead of FFT_2D_FAST...*/
  for( i = 0; i < *ny * *nx; i++) 
     {
     modsq[i] *= norm_fft2;
     snrm[i] *= norm_fft4;
     }

   yce_ng = 0;
   for(ng = 0; ng < *ngamma; ng++)
     {
     yce1[yce_ng] *= norm_fft3;
     yce_ng++; 
     yce1[yce_ng] *= norm_fft3;
     yce_ng++; 
     yce1[yce_ng] *= norm_fft6;
     yce_ng++; 
     yce1[yce_ng] *= norm_fft6;
     yce_ng++; 
     }

/*******************************************************/
/* Return if no correction is needed: */
if(!*photon_correction) return(0);

/*******************************************************/
/* First the bispectrum */

  xphot2 = *xphot * *xphot;
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list.
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       iix = ((ixy_1[nb] + *nx) % *nx);
       iiy = ((ixy_2[nb] + *ny) % *ny);
/* Here xr is used to store the mean normalized square modulus: */
       xr[nb] = modsq[iix + iiy * *nx];
     }

/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* and correction from photon noise effects:
*/
 w2 = 2. *  *xphot;
 yce_ng = 0;
 iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
/* Photon noise correction 
*/
     work1 = - (xr[k1] + xr[k2] + xr[k3]) + w2;
     yce1[yce_ng] += work1;

/* Estimation of the noise with the sum of squares: */
     yce_ng++; yce_ng++;
     yce1[yce_ng] -= work1*work1;
     yce_ng++; yce_ng++;
  }

/*******************************************************/
/* Then correcting the squared modulus: */
  xphot4 = xphot2 * xphot2;
  for( i = 0; i < *ny * *nx; i++) 
     {
/* Photon noise correction: (biased_sq = xphot + xphot_sq * unbiased_sq)*/
      modsq[i] -= *xphot;
/* Normalization for compatibility with previous computations: */
      modsq[i] /= xphot2;
      snrm[i] /= xphot4;
    }

/*******************************************************/
xphot3 = *xphot * *xphot * *xphot;
xphot6 = xphot3 * xphot3;
yce_ng = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     yce1[yce_ng] /= xphot3;
     yce_ng++;
     yce1[yce_ng] /= xphot3;
     yce_ng++;
     yce1[yce_ng] /= xphot6;
     yce_ng++;
     yce1[yce_ng] /= xphot6;
     yce_ng++;
 }

return(0);
}
/*******************************************************/
int rearrange(float *yce1, INT4 *ngamma, INT4 *ydim1)
{
int isize, ydim;
register int ng, yce_ng;
float *work;

ydim = *ydim1;
isize = 4 * ydim * sizeof(float);
JLP_GVM(&work,&isize);

/* Erases work array: */
for(ng = 0; ng < 4 * ydim; ng++) work[ng] = 0.; 

/* Transfer to temporary array: */
yce_ng = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     work[ng] = yce1[yce_ng];
     yce_ng++;
     work[ng + ydim] = yce1[yce_ng];
     yce_ng++;
     work[ng + 2 * ydim] = yce1[yce_ng];
     yce_ng++;
     work[ng + 3 * ydim] = yce1[yce_ng];
     yce_ng++;
 }

/* Transfer back to yce1: */
for(ng = 0; ng < 4 * ydim; ng++) yce1[ng] = work[ng]; 

JLP_FVM(&work);
return(0);
}
