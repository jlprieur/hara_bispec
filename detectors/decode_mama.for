C++**************************************************************************
C Program DECODE_MAMA
C To decode speckle files generated by MAMA
C Output: bispectrum phase factor, modulus (squared) of the spectrum,
C         and long integration.
C
C Output file for the details of the input parameters: DECODE_MAMA.DAT
C
C Tests: fft_nag.for or fft_jlp.for give exactly the same FFT,
C        and JLP version goes as fast as the nag version (maybe a bit
C        faster even). But for non square images, NAG is the only choice.
C
C JLP
C Version: 09-10-92
C--**************************************************************************
C Nota: C@ points to debugging instructions
C
	PROGRAM DECODE_MAMA

C  POUR IR=25
	PARAMETER (NGMAX=187566,IDIM=256)

C  POUR IR=30
C	PARAMETER (NGMAX=388400,IDIM=256)

	REAL IMAGE(IDIM,IDIM),LONG_INTEG(IDIM,IDIM),AUTOCO(IDIM,IDIM)
C Modulus squared, and bispectral phase factor:
	REAL MODSQ(IDIM,IDIM),YCE1(NGMAX,4)
C SNRM: SNR of the squared modulus:
	REAL RE(IDIM,IDIM),IM(IDIM,IDIM),SNRM(IDIM,IDIM)
	REAL TLIMIT,TINTEGRAT,FFIELD
	REAL AT,ABSTIME,XBAD_FRAMES
C !! integer*2 !!!!
	INTEGER*2 IBUF(8192)
	INTEGER*4 NX1,NY1,IXSTART,IYSTART,IXEND,IYEND,IREDUC
	INTEGER*4 NCARA,NXFF,NYFF,IFRAME,NFRAME,NPHOTONS
	LOGICAL*1 IBUFT(16384)
	CHARACTER LONGNAME*40
	CHARACTER FILE1*40,FFNAME*40,COMMENTS*80,NAME*40
C Common/TEST:
        REAL OLD_SNRM,SUM1,SUMSQ1
        INTEGER N1
	EQUIVALENCE (IBUF(1),IBUFT(1))
	COMMON/MTIME/TLIMIT,TINTEGRAT,AT,IFRAME,NFRAME,XBAD_FRAMES
	COMMON/MIMAGE/IMAGE,NX1,NY1,NPHOTONS,IXSTART,IYSTART,
     1	IXEND,IYEND,IREDUC,FFIELD(1024,256),NXFF,NYFF,XPHOT
	COMMON/MFRAMES/LONG_INTEG
C Common block with MAMA_SPIMAGE 
	COMMON/BISP1/MODSQ,SNRM,RE,IM,YCE1,IR,NBETA,NGAMMA
	COMMON/MAUTOC/AUTOCO
C Test for SNR computation:
	COMMON/TEST/OLD_SNRM,SUM1,SUMSQ1,N1
 
10	FORMAT(A)
 
	CALL JLP_BEGIN
 
C Initialization of COMMON/TEST:
           OLD_SNRM=0
           SUM1=0
           SUMSQ1=0
           N1=0

C File with gravity center:
C	OPEN(12,STATUS='UNKNOWN',FILE='grav.dat')

	OPEN(2,STATUS='UNKNOWN',FILE='decode_mama.log',ERR=999)
	WRITE(2,58)
	WRITE(6,58)
58	FORMAT(' Program decode_mama Version 09-10-92',/,
     1	' Matrices up to 256x256')
 
C UV Coverage:
	WRITE(6,*) ' Radius (IR) of uv-coverage ?'
	READ(5,*) IR
	CALL COVERA(IR,NBETA,NGAMMA)
 
C Speckle data:
95	WRITE(6,*) ' INPUT FILE (SPECKLE DATA) :'
	READ(5,10) FILE1
C	OPEN(10,FILE=FILE1,
C     1	FORM='UNFORMATTED',STATUS='OLD',ERR=95)
C Imode=0 (read only)
	IMODE=0
	CALL JLP_OSDOPEN(FILE1,40,IMODE,IFID,ISTAT)
	 IF(ISTAT.NE.0)THEN
	    WRITE(6,*) ' Fatal error opening the data input file'
	    GOTO 998
	 ENDIF
 
C Window 256x224 on the initial frame (x : y) = (385->640 : 1->224)
C With a compression by 8, so that we have 32x28 frames.
c	IXSTART=385
c	IYSTART=1
c	IREDUC=8
	WRITE(6,29)
29	FORMAT(' Center of the window IX,IY (512,112), ',
     1	' reduction factor (max=8),',/,5X,
     1	' and size NX,NY (32,28) (max=256,256) :')
	READ(5,*) IXCENT,IYCENT,IREDUC,NX1,NY1
	IXSTART=IXCENT+1-IREDUC*NX1/2
	IYSTART=IYCENT+1-IREDUC*NY1/2
	IXEND=IXSTART-1+NX1*IREDUC
	IYEND=IYSTART-1+NY1*IREDUC
	WRITE(6,30) IXSTART,IXEND,IYSTART,IYEND,IREDUC,NX1
	WRITE(2,30) IXSTART,IXEND,IYSTART,IYEND,IREDUC,NX1
30	FORMAT('  IXSTART, IXEND, IYSTART, IYEND :',4(I5,2X),/,
     1	'  IREDUC, ISIZE : ',2(I5,2X))
C
	IF((IXSTART.LT.1).OR.(IYSTART.LT.1)
     1	.OR.(IXEND.GT.1024).OR.(IYEND.GT.256)) THEN
	   WRITE(6,96)
	   WRITE(2,96)
96	   FORMAT(' Fatal error: window too large',
     1	' relative to the MAMA format')
	   GOTO 998
	ENDIF
 
C Check the compatibility with IR:
	ITEST=2*IR+1
	IF((ITEST.GT.NX1).OR.(ITEST.GT.NY1))THEN
	   WRITE(6,97)
	   WRITE(2,97)
97	   FORMAT(' FATAL error: the size of the images',
     1	' would be too small relative to IR')
	   GOTO 998
	ENDIF
 
	WRITE(6,98)
98	FORMAT(' Integration time in msec for the frames',
     1	' and number of frames:')
	READ(5,*) TINTEGRAT,NFRAME
	TLIMIT=TINTEGRAT
	IFRAME=1
 
C Enter the flat field:
	WRITE(6,73)
73	FORMAT(/,' ********ENTER THE FLAT FIELD:*******')
C Ask for the format of the images:
	CALL JLP_INQUIFMT
	FFNAME=' '
	I=1024
	CALL JLP_READIMAG(FFIELD,NXFF,NYFF,I,FFNAME,COMMENTS)
	  IF(NXFF.NE.1024.OR.NYFF.NE.256)THEN
	    WRITE(2,76)
76	    FORMAT(' Fatal error: The flat field has not 1024x256 pixels')
	    GOTO 998
	  ENDIF
C Normalization of the flat field on the working area:
	CALL NORMALIZE
 
C Header for the logfile:
	WRITE(6,92) FILE1,FFNAME,TINTEGRAT,NFRAME,
     1	IXCENT,IYCENT,IREDUC,NX1,NY1
	WRITE(2,92) FILE1,FFNAME,TINTEGRAT,NFRAME,
     1	IXCENT,IYCENT,IREDUC,NX1,NY1
92	FORMAT('    Program DECODE_MAMA.   Version 10-06-92',/,/,
     1  ' Swaped buffer (to correct Vax), Non apodized flat field',
     1  ' Flat field range: between 0.1 and 10.',/,
C     1  ' With BISPEC2 (non corrected for photon noise)',/,
     1  ' With BISPEC1 (corrected for photon noise)',/,
     1	' Input file:',A,/,' Flat field :',A,/,
     1	' Integration time in ms (wanted):',1PG12.3,/,
     1	' Number of frames (wanted):',I8,/,
     1	' IXCENT, IYCENT, IREDUC, NX1, NY1,',5(2X,I4),/)
 
C Setting ABSTIME:
	 ABSTIME=0.0
 
	 XPHOT=0.
	 NPHOTONS=0
	 XBAD_FRAMES=0.
	 CALL ERASE_IMAGE(RE,NX1,NY1,IDIM)
	 CALL ERASE_IMAGE(IM,NX1,NY1,IDIM)
	 CALL ERASE_IMAGE(MODSQ,NX1,NY1,IDIM)
	 CALL ERASE_IMAGE(SNRM,NX1,NY1,IDIM)
	 CALL ERASE_IMAGE(YCE1,NGAMMA,4,NGMAX)

C** Reading the file:
	 NMAXBLOCK=302
C READ_MAMA created only 302 blocks (since the first was the header
C and was not recorded)
	 NCARA=16384
	 NBUF=NCARA/2
	 DO K=1,NMAXBLOCK
	   CALL JLP_OSDREAD(IFID,IBUFT,NCARA,ISTAT)
	   IF(ISTAT.NE.0)THEN
	      IF(K.EQ.1)THEN
	      WRITE(6,*) ' Fatal error reading the data in the input file'
	      CALL JLP_OSDCLOSE(IFID,ISTAT)
	      GOTO 998
	      ELSE
C Normal exit of the loop:
	      GOTO 9999
	      ENDIF
	   ENDIF
C	   READ(10,END=9999) (IBUFT(I),I=1,NCARA)
C Swaping (since data coming from the Vax):	
	   CALL SWAP(IBUF,NBUF)
	   WRITE(2,111)K
	   WRITE(6,111)K
111	   FORMAT(' RECORD #',I8)
C Decoding now, integrating the individual frames,
C mean spectrum, bispectrum :
	   CALL DECODE_SPECKLE(IBUF,NBUF,ABSTIME,ISTATUS)
	   IF(ISTATUS.NE.0)GOTO 9999
	 END DO
 
C End:
C9999	CLOSE(10)
9999	CALL JLP_OSDCLOSE(IFID,ISTAT)
	IF(ISTAT.NE.0)THEN
	  WRITE(6,*) ' Fatal error closing the data input file'
	ENDIF
 
C Check if EOF encountered:
	NFRAME=IFRAME-1
        IF(NFRAME.EQ.0)THEN
          WRITE(2,129)
          WRITE(6,129)
129       FORMAT(' Error: end of file reached before reaching exposure',
     1      ' time')
          IX=-1
          IY=-1
          TLIMIT=AT
          TINTEGRAT=AT
	  CALL MAMA_SPIMAGE(IX,IY,AT,ISTATUS)
C Reset NFRAME after calling MAMA_SPIMAGE:
          NFRAME=1
        ENDIF

C Recentre Fourier transforms:
        CALL RECENTRE(MODSQ,MODSQ,NX1,NY1,IDIM)
        CALL RECENTRE(SNRM,SNRM,NX1,NY1,IDIM)

C Diagnostic:
	IXC=NX1/2+1
	IYC=NY1/2+1
	W1=MODSQ(IXC,IYC)/FLOAT(NFRAME)
C	XPHOT=SQRT(W1)
C Take the real mean number of photons per frame 
C (not corrected by flat field)
	XPHOT=XPHOT/FLOAT(NFRAME)
	WRITE(6,88) XPHOT,NFRAME,XBAD_FRAMES,W1
	WRITE(2,88) XPHOT,NFRAME,XBAD_FRAMES,W1
88	FORMAT(' Mean Nphotons/fr:',F14.2,' Nframes :',I8,/,
     1	' Frames with less than 20 photons:',
     1   F12.0,/,' Maximum of MODSQ : ',G12.4,2X,/,
     1  ' ********* Output of the following arrays: ********')
C     1	' Frames with less than 20 photons or too far from center:',
 
C Store this information in COMMENTS:
	 WRITE(COMMENTS,38) FILE1(1:12),TINTEGRAT,NFRAME,XPHOT
38	 FORMAT(' ',A12,1PG11.4,1X,I9,1X,1PG12.5,' (dt,Nf,Np)')
	 WRITE(6,10) COMMENTS
	 WRITE(2,10) COMMENTS

C Simply divide the integrated frames by the number of frames:
	  W1=REAL(NFRAME)
	  CALL MEAN_FRAMES(MODSQ,NX1,NY1,IDIM,W1)
	  CALL MEAN_FRAMES(SNRM,NX1,NY1,IDIM,W1)
	  CALL MEAN_FRAMES(YCE1,NGAMMA,4,NGMAX,W1)
	  CALL MEAN_FRAMES(LONG_INTEG,NX1,NY1,IDIM,W1)
c#	  W1=AUTOCO(1,1)
c#	  CALL MEAN_FRAMES(AUTOCO,NX1,NY1,IDIM,W1)
 
C SNR of square modulus:
	CALL SNR_MODSQ(SNRM,MODSQ,NX1,NY1,IDIM)
	WRITE(6,39)
39	FORMAT(/,' ********OUTPUT OF THE SNR OF THE SQUARED MODULUS:*******')
	   NAME='snrm      '
	   CALL JLP_WRITEIMAG(SNRM,NX1,NY1,IDIM,NAME,COMMENTS)
	   WRITE(2,36)
	   WRITE(6,36)
36	   FORMAT(' SNR of the squared modulus in: "snrm"')
 
C Squared modulus:
	WRITE(6,69)
69	FORMAT(/,' ********OUTPUT OF THE MEAN SQUARED MODULUS:*******')
	   NAME='modsq      '
	   CALL JLP_WRITEIMAG(MODSQ,NX1,NY1,IDIM,NAME,COMMENTS)
	   WRITE(2,66)
	   WRITE(6,66)
66	   FORMAT(' Mean spectrum (modulus squared) in: "modsq"')
 
C Bipsectrum:
C Signal to noise estimation:
	  DO NG=1,NGAMMA
C Real variance: 
	    WORK1=YCE1(NG,3)-YCE1(NG,1)*YCE1(NG,1)
C Imaginary variance:
	    WORK2=YCE1(NG,4)-YCE1(NG,2)*YCE1(NG,2)
C Full variance:
	    WORK=WORK1+WORK2
	    WORK=MAX(1.E-14,WORK)
C SNR is (modulus of signal /sigma):
	    YCE1(NG,3)=SQRT(YCE1(NG,1)*YCE1(NG,1)+
     1        YCE1(NG,2)*YCE1(NG,2))/SQRT(WORK)
C	    YCE1(NG,3)=WORK1
C	    YCE1(NG,4)=WORK2
	  END DO
	   NAME='bisp1     '
	   CALL JLP_WRITEIMAG(YCE1,NGAMMA,3,NGMAX,NAME,COMMENTS)
	   WRITE(2,37)
37	   FORMAT(' Mean bispectrum in: "bisp1" (list')
 
	WRITE(6,49)
49	FORMAT(/,' ****OUTPUT OF THE LONG INTEGRATION FRAME:*****')
	   LONGNAME='long     '
	   CALL JLP_WRITEIMAG(LONG_INTEG,NX1,NY1,IDIM,LONGNAME,
     1	COMMENTS)
	   WRITE(2,47)
	   WRITE(6,47)
47	   FORMAT(' Long integ. (mean) of the frames in: "long" ')
 
C Autocorrelation: 
	i=0
	if (i.eq.0)goto 998
	WRITE(6,63)
63	FORMAT(/,' ********OUTPUT OF THE AUTOCORRELATION:*******')
	   WRITE(COMMENTS,64) FILE1(1:12),TINTEGRAT,NFRAME
64	   FORMAT('Autocorr. ',A12,' Integ., frames:',F12.2,1X,I12)
	   WRITE(6,10) COMMENTS
	   WRITE(2,10) COMMENTS
	   NAME='autoc      '
	   CALL JLP_WRITEIMAG(AUTOCO,NX1,NY1,IDIM,NAME,COMMENTS)
	   WRITE(2,65)
	   WRITE(6,65)
65	   FORMAT(' Autocorrelation in: "autoc"')
 
C End:
998	CLOSE(2)
C Closing gravity center file:
C	CLOSE(12)
	PRINT *,' Logfile in: decode_mama.log'
	CALL JLP_END
	STOP
999	PRINT *,' Fatal error opening: decode_mama.log'
	CALL JLP_END
	STOP
	END
C********************************************************************
C Subroutine DECODE_SPECKLE
C to decode the bytes and write the output on the data file:
C xxxxxxxx xxxxxxxx xxxxxxxx xxxxxxxx
C********************************************************************
	SUBROUTINE DECODE_SPECKLE(IBUF,NBUF,ABSTIME,ISTATUS)
	REAL*4 AT,ABSTIME,TEST
	REAL*4 TLIMIT,TINTEGRAT,XBAD_FRAMES
 	INTEGER*2 IBUF(*),WORD1,WORD2
	INTEGER*2 IX,IYL,IYM,IY,IRT,IATL,IATM
	INTEGER*4 NBUF,ISTATUS,I,I0
C	INTEGER*2 JLP_AND,JLP_BTEST,JLP_OR
	INTEGER*4 JLP_AND,JLP_BTEST,JLP_OR
	INTEGER*4 IFRAME,NFRAME
	COMMON/MTIME/TLIMIT,TINTEGRAT,AT,IFRAME,NFRAME,XBAD_FRAMES
        EXTERNAL JLP_AND,JLP_BTEST,JLP_OR 
   
	ISTATUS=0
	SPURIOUS=-0.2453
 
C Reference to start with (Cf. error on sequential numbers...)
	I0=0
 
	DO I=1,NBUF-1,2
 
	WORD1=IBUF(I+I0)
	WORD2=IBUF(I+I0+1)
	TEST0=FLOAT(WORD1)*FLOAT(WORD2)
 
C IF 54321098 76543210
C    00xxxxxx xxxxxxxx : event (1)
C    01xxxxxx xxxxxxxx : event (2)
C    10xxxxxx xxxxxxxx : absolute time (1)
C    11xxxxxx xxxxxxxx : absolute time (2)
C Please note that BITEST (Vax) becomes BTEST (Sun)
	IF((JLP_BTEST(WORD1,14).EQ.1).OR.
     1	(JLP_BTEST(WORD2,14).NE.1)) THEN
	      WRITE(6,80) I,WORD1,WORD2
	      WRITE(2,80) I,WORD1,WORD2
80	      FORMAT(' PB with pixel:',I6,
     1	' and next, non sequential! ',2(I6,1X),/,
     1	' I CORRECT BY SHIFTING THE ORIGIN')
	      I0=I0+1
	ELSEIF(TEST0.LT.0)THEN
	      WRITE(6,81) I,WORD1,WORD2
	      WRITE(2,81) I,WORD1,WORD2
81	      FORMAT(' PB with pixel:',I6,
     1	' and next, unknown code: neither event nor clock!',
     1	2(I6,1X))
	ELSE
C
C From now on: either event or clock tag:
	  IF(WORD1.GE.0) THEN
C Decoding the address, and relative time:
C    00yyyyxx xxxxxxxx     IYL, IXM, IYL
C    01tttttt ttttyyyy     IRTM, IRTL, IYM
C
C IX (I add 1 to go from 1 to 1024):
C Nota: IAND (Vax) becomes AND (Sun)
	    IX=JLP_AND(WORD1,1023)+1
C IYL least signif. bits. :
	    IYL=JLP_ISHFT(WORD1,-10)
	    IYL=JLP_AND(IYL,15)
C IYM most signif. bits. :
	    IYM=JLP_AND(WORD2,15)
	    IYM=JLP_ISHFT(IYM,4)
C IY (I add 1 to go from 1 to 1024):
	    IY=JLP_OR(IYM,IYL)+1
C IRT: relative time 1/100msec
	    IRT=JLP_ISHFT(WORD2,-4)
	    IRT=JLP_AND(IRT,1023)
	    OLD_AT=AT
	    AT=FLOAT(IRT)/100.+ ABSTIME
C Check the consistency of the data:
	    TEST=OLD_AT-AT
	    IF(TEST.GT.0)THEN
	        WRITE(2,112) OLD_AT,AT
C@	        WRITE(6,112) OLD_AT,AT
112	        FORMAT(' ERROR: inconsistent times.',
     1	' Previous:',F12.2,' new:',F12.2)
	       IF((AT-ABSTIME).LT.0.5.AND.(OLD_AT-ABSTIME).GT.9.5) THEN
	           AT=AT+10.24
	           ABSTIME=ABSTIME+10.24
	           WRITE(6,511) AT
	           WRITE(2,511) AT
511                FORMAT(' Warning: I assume missing tag.',
     1    ' Corrected time:',F12.2)
              ENDIF
             ENDIF
 
C@	PRINT *,' X,Y,RT,AT',IX,IY,IRT,AT
 
	    CALL MAMA_SPIMAGE(IX,IY,ISTATUS)
	    IF(ISTATUS.NE.0)GOTO 9999
 
	   ELSE
C IF(WORD1.LT.0)
C Decoding the absolute time:
C    10xxxxxx xxxxxxxx : absolute time IATL
C    11xxxxxx xxxxxxxx : absolute time IATM
	    IATL=JLP_AND(WORD1,16383)
	    IATM=JLP_AND(WORD2,255)
C Absolute time: one tag every 10.24ms
	    ABSTIME1=(FLOAT(IATL)+FLOAT(IATM)*16384.)*10.24
C@	  PRINT *,' ABSTIME:',ABSTIME1
 
C Checking for the consistency of the clock:
	    TEST1=(ABSTIME1-ABSTIME)/10.24
	    TEST2=ABS(TEST1-NINT(TEST1))
C If the new value implies that
C more than 4 tags have been missed I don't change anything:
	     IF((TEST1.LT.0.).OR.(TEST1.GT.4.).OR.(TEST2.GT.0.1))THEN
	        WRITE(2,543)ABSTIME1,ABSTIME,WORD1,WORD2
C@	        WRITE(6,543)ABSTIME1,ABSTIME,WORD1,WORD2
543	        FORMAT(' ERROR: spurious clock:',
     1	F12.2,' (old clock:',F12.2,')',
     1   ' (Coded words:',2(1X,I6),')')
C Check if it is not a shift:
	        IF(ABS(ABSTIME1-SPURIOUS-10.24).LT.0.01)THEN
	           ABSTIME=ABSTIME1
	           WRITE(2,544) ABSTIME
C@	           WRITE(6,544) ABSTIME
544	           FORMAT(' BIG ERROR: lost records!',
     1	' I set the clock to:',F12.2)
	        ENDIF
	        SPURIOUS=ABSTIME1
	     ELSE
	         ABSTIME=ABSTIME1
	     ENDIF
 
	   ENDIF
 
	ENDIF
 
	END DO
 
9999	RETURN
	END
C********************************************************************
C Subroutine MAMA_SPIMAGE
C Integrates the counts on speckle images
C********************************************************************
	SUBROUTINE MAMA_SPIMAGE(IX,IY,ISTATUS)
C  POUR IR=25
	PARAMETER (NGMAX=187566,IDIM=256)

C  POUR IR=30
C	PARAMETER (NGMAX=388400,IDIM=256)

	REAL*4 MODSQ(IDIM,IDIM),YCE1(NGMAX,4)
	INTEGER*4 IR,NBETA,NGAMMA
	REAL*4 IMAGE(IDIM,IDIM),FFIELD
	REAL*4 AT,XC_GRAV,YC_GRAV,XOFFSET,YOFFSET
	REAL*4 RE(IDIM,IDIM),IM(IDIM,IDIM),SNRM(IDIM,IDIM)
	REAL*4 TLIMIT,TINTEGRAT,XBAD_FRAMES
	INTEGER*2 IX,IY
	INTEGER*4 IFRAME,NFRAME
	INTEGER*4 NPHOTONS,NX1,NY1,IXSTART,IYSTART,IREDUC
	INTEGER*4 ISTATUS,NXFF,NYFF,IXEND,IYEND
	COMMON/MTIME/TLIMIT,TINTEGRAT,AT,IFRAME,NFRAME,XBAD_FRAMES
	COMMON/MIMAGE/IMAGE,NX1,NY1,NPHOTONS,IXSTART,IYSTART,
     1	IXEND,IYEND,IREDUC,FFIELD(1024,256),NXFF,NYFF,XPHOT
 
	COMMON/BISP1/MODSQ,SNRM,RE,IM,YCE1,IR,NBETA,NGAMMA
	
C Check if the limit has been overtaken:
	IF(AT.GE.TLIMIT)THEN
C@	  PRINT *,' AT,TLIMIT',AT,TLIMIT
 
C Check if the number of photons is high enough:
	  IF(NPHOTONS.LE.20)THEN
	     WRITE(2,79) NPHOTONS
	     WRITE(6,79) NPHOTONS
79	     FORMAT(' @WARNING: not enough photons, for this frame,',
     1	' Nph=',I5)
	     XBAD_FRAMES=XBAD_FRAMES+1.
	   ELSE	

C Center of gravity:
C	    CALL CENTER_GRAV(IMAGE,NX1,NY1,IDIM,XC_GRAV,YC_GRAV)

C	    XOFFSET=XC_GRAV-FLOAT(NX1/2)
C	    XOFFSET=ABS(XOFFSET)
C	    YOFFSET=YC_GRAV-FLOAT(NY1/2)
C	    YOFFSET=ABS(YOFFSET)

C           IF(XOFFSET.GT.30.OR.YOFFSET.GT.30)THEN
C	      WRITE(2,56) XOFFSET,YOFFSET,XC_GRAV,YC_GRAV 
C	      WRITE(6,56) XOFFSET,YOFFSET,XC_GRAV,YC_GRAV 
C56	      FORMAT(' @WARNING: frame decentred, X,Yoffset, X,Ygrav:',
C     1    4(1X,F5.1))
C	      XBAD_FRAMES=XBAD_FRAMES+1.

C	    ELSE

C	     WRITE(6,23) IFRAME,XC_GRAV,YC_GRAV
C23	     FORMAT(' Frame #',I5,' Gravity center: ',2(1X,G12.5))
C	     WRITE(12,24) IFRAME,XC_GRAV,YC_GRAV
C24	     FORMAT(I5,2(1X,G12.5))

	     IF(MOD(IFRAME,100).EQ.1) WRITE(6,23) IFRAME,NPHOTONS
23	     FORMAT(' Frame #',I8,' Nphotons (before ffield correction):',I8)
C Number of photo-events (not corrected by flat-field):
            XPHOT=XPHOT+FLOAT(NPHOTONS)
C Computing the spectrum:
C Transfer:
             DO 6 J=1,NY1
               DO 7 I=1,NX1
                 RE(I,J)=IMAGE(I,J)
                 IM(I,J)=0.
7              CONTINUE
6            CONTINUE
C Fourier Transform:
             KOD=1
C             WRITE(6,*) ' Start FFT'
             CALL FFT_2D(RE,IM,NX1,NY1,IDIM,KOD)

C Computes the mean spectrum and bispectrum 
C BISPEC1: (correction from photon noise)
C           PRINT *,' Calling BISPEC1' 
  	     CALL BISPEC1(RE,IM,MODSQ,SNRM,NX1,NY1,IDIM,
     1      YCE1,IR,NBETA,NGAMMA)
C	     CALL BISPEC2(RE,IM,MODSQ,SNRM,NX1,NY1,IDIM,
C     1	       YCE1,IR,NBETA,NGAMMA)
 
C Mean and std dev. of bins with NNFR frames:
C This shows that the mean is not reach before 30 to 100 values have been computed
C and therefore, a SNR value taking into account a series of 10000 frames
C should be credited of a gain in SNR of the order of sqrt(100)=10 only (not sqrt(10000)),
C since the mean of bins with 10000 frames cannot be reached with only one set of 10000 frames. 
C              NNFR=16
C              IF(MOD(IFRAME,NNFR).EQ.0)THEN
C                CALL SNR_ESTIM(MODSQ(10,10),SNRM(10,10),NNFR,IFRAME)
C              ENDIF
 
C Long integration:
              CALL SUM_FRAMES(IMAGE,NX1,NY1)

C Autocorrelation:
c#	      CALL SUM_AUTOCOR(IMAGE,NX1,NY1,NX1)
 
C Check if should stop:
	       IFRAME=IFRAME+1
	       IF(IFRAME.GT.NFRAME) THEN
	         ISTATUS=1
	         RETURN
	      ENDIF
C	     ENDIF
 
	  ENDIF
 
C Prepares the next step:
	   TLIMIT=TLIMIT+TINTEGRAT
C@	   PRINT *,' IFRAME,NFRAME,TLIMIT,TINTEGRAT',
C@     1	IFRAME,NFRAME,TLIMIT,TINTEGRAT
C Cleans the previous image:
	    NPHOTONS=0
	    CALL ERASE_IMAGE(IMAGE,NX1,NY1,IDIM)
	ENDIF
 
C Add the new photon now:
	   IF((IX.GE.IXSTART.AND.IX.LE.IXEND).AND.
     1	(IY.GE.IYSTART.AND.IY.LE.IYEND))THEN
	     IXX=1+INT((IX-IXSTART)/IREDUC)
	     IYY=1+INT((IY-IYSTART)/IREDUC)
	     NPHOTONS=NPHOTONS+1

C Flat field correction, and integration of the photons on IMAGE:
	     IMAGE(IXX,IYY)=IMAGE(IXX,IYY)+FFIELD(IX,IY)

	  ENDIF
	RETURN
	END
C********************************************************************
C Subroutine ERASE
C Erases the image
C********************************************************************
	SUBROUTINE ERASE_IMAGE(IMAGE,NX,NY,IDIM)
	REAL*4 IMAGE(IDIM,*)
	INTEGER*4 NX,NY
	DO J=1,NY
	  DO I=1,NX
	     IMAGE(I,J)=0.
	  END DO
	END DO
	RETURN
	END
C********************************************************************
C Subroutine SUM_AUTOCOR
C Computes the sum of all the autocorrelations
C********************************************************************
	SUBROUTINE SUM_AUTOCOR(IMAGE,NX,NY,IDIM1)
	PARAMETER (IDIM=256)
	REAL*4 AUTOCO(IDIM,IDIM),SUM
	REAL*4 IMAGE(IDIM1,*)
	INTEGER*4 NX,NY,I,J,II,JJ,IIMAX,JJMAX
	COMMON/MAUTOC/AUTOCO
	
C Computes the autocorrelation:
	DO J=1,NY
	  JJMAX=NY-J
	  DO I=1,NX
	    IIMAX=NX-I
	    SUM=0.
	      DO JJ=1,JJMAX
	        DO II=1,IIMAX
C Dividing by 1000 to reduce the magnitude of the numbers:
	          SUM=SUM+IMAGE(II,JJ)*IMAGE(II+I,JJ+J)/1000.
	        END DO
	      END DO
	    AUTOCO(I,J)=SUM
	  END DO
	END DO
 
	RETURN
	END
C********************************************************************
C Subroutine SUM_FRAMES
C To add up all the frames
C********************************************************************
	SUBROUTINE SUM_FRAMES(IMAGE,NX,NY)
	PARAMETER (IDIM=256)
	REAL*4 LONG_INTEG(IDIM,IDIM),IMAGE(IDIM,*)
        INTEGER*4 NX,NY,I,J
	COMMON/MFRAMES/LONG_INTEG

C Add up all the frames:
       	DO J=1,NY
         DO I=1,NX
           LONG_INTEG(I,J)=LONG_INTEG(I,J)+IMAGE(I,J)
         END DO
        END DO

	RETURN
	END
C********************************************************************
C Subroutine NORMALIZE
C To normalize the flat field on the working area
C Good area:
C	NXFF=960
C	NYFF=224
C JLP91: Please note that we take 1/FFIELD in order to multiply with
C the flat field... (easier to handle with padding filter and zeroes...)
C********************************************************************
	SUBROUTINE NORMALIZE
	PARAMETER (IDIM=256)
	REAL*4 FFIELD,IMAGE(IDIM,IDIM)
	REAL*8 XMEAN
	REAL*4 MIN_VALUE,MAX_VALUE,NNULL
	INTEGER*4 NXFF,NYFF
	INTEGER*4 IXSTART,IYSTART,IXEND,IYEND,IREDUC
	CHARACTER NAME*40,COMMENTS*80
	COMMON/MIMAGE/IMAGE,NX1,NY1,NPHOTONS,IXSTART,IYSTART,
     1	IXEND,IYEND,IREDUC,FFIELD(1024,256),NXFF,NYFF,XPHOT
 
C Computing the mean on the good area:
	XMEAN=0.
	IY2=MIN(IYEND,210)
	DO J=IYSTART,IY2
	  DO I=IXSTART,IXEND
	     XMEAN=XMEAN+FFIELD(I,J)
	  END DO
	END DO
	XMEAN=XMEAN/(FLOAT(IY2-IYSTART+1)*FLOAT(IXEND-IXSTART+1))
	WRITE(6,58) XMEAN
	WRITE(2,58) XMEAN
58	FORMAT(' First mean value of the Flat Field: ',G12.5)
 
C Then normalization to 1:
c	NYFF1=224
c	NXFF1=960
C This value should not be too small, otherwise it distorts the spectrum!!!
C (0.01 is too small, 0.33 not too bad,...)
C	MIN_VALUE=0.33
C	MAX_VALUE=1.66
	MIN_VALUE=0.10
        MAX_VALUE=10.0
	SUM=0.
	DO J=IYSTART,IYEND
	  DO I=IXSTART,IXEND
	     FFIELD(I,J)=FFIELD(I,J)/XMEAN
	     FFIELD(I,J)=MAX(FFIELD(I,J),MIN_VALUE)
	     FFIELD(I,J)=MIN(FFIELD(I,J),MAX_VALUE)
	     SUM=SUM+FFIELD(I,J)
	  END DO
	END DO
	XMEAN=SUM/(FLOAT(IY2-IYSTART+1)*FLOAT(IXEND-IXSTART+1))
	WRITE(6,59) XMEAN
	WRITE(2,59) XMEAN
59	FORMAT(' Second mean of the Flat Field: ',G12.5)
 
C Inversion and fine normalization to 1 of the flat field:
C Fine tuning to allow NPHOTON = XPHOT from FFT and good photon noise
C correction:
	DO J=IYSTART,IYEND
	  DO I=IXSTART,IXEND
            FFIELD(I,J)=XMEAN/FFIELD(I,J)
	  END DO
	END DO

C Attenuation in the edges to avoid central bar in Fourier domain, 
C since the flat field is such that 256x256 has a blank area.
C THIS PART WAS NOT CONVINCING, SO I REMOVE IT (JLP92)
	IF(IYEND.GT.440)THEN
	  PRINT *,' *********NORMALIZE/ Apodization!!!!!!!' 
	  IYW=50
	  W1=3.14159/FLOAT(IYW)
          DO J=0,IYW
	    JJ=IYSTART+J
	    JJJ=210-J
	    WORK=0.5*(1.-COS(W1*FLOAT(J)))
	    DO I=IXSTART,IXEND
	      FFIELD(I,JJ)=FFIELD(I,JJ)*WORK
	      FFIELD(I,JJJ)=FFIELD(I,JJJ)*WORK
	    END DO
	  END DO
          DO J=211,IYEND
	    DO I=IXSTART,IXEND
	      FFIELD(I,J)=0.
	    END DO
	  END DO
         ENDIF

C Test:
	COMMENTS=' '
	NAME='ffield_test      '
	PRINT *,' Output of the synthetic Flat Field: ',NAME
	CALL JLP_WRITEIMAG(FFIELD(IXSTART,IYSTART),NX1,NY1,1024,NAME,
     1       COMMENTS)
	RETURN
	END
C********************************************************************
C Subroutine MEAN_FRAMES
C Computes the mean frame
C********************************************************************
	SUBROUTINE MEAN_FRAMES(A,NX,NY,IDIM,XQUO)
	REAL*4 A(IDIM,*),XQUO
	INTEGER*4 NX,NY
	
	IF(XQUO.NE.0)THEN
	  DO J=1,NY
	    DO I=1,NX
	      A(I,J)=A(I,J)/XQUO
	    END DO
	  END DO
	ELSE
	  PRINT *,' Mean_frames/Fatal XQUO is null '
	ENDIF
	
	RETURN
	END
 
C********************************************************************
C Subroutine SPEC_RATIO
C From proceedings of NOAO/ESO workshop "High resolution imaging
C with interferometry", 1988, J.C. Christou, page 97.
C********************************************************************
	SUBROUTINE SPEC_RATIO(MODSQ,MRE,MIM,NX,NY,IDIM)
	INTEGER*4 NX,NY,IDIM
	REAL*4 MRE(IDIM,*),MIM(IDIM,*),MODSQ(IDIM,*)
	
	DO J=1,NY
	   DO I=1,NX
	      IF(MODSQ(I,J).GE.0)THEN
	        MODSQ(I,J)=(MRE(I,J)**2+MIM(I,J)**2)/MODSQ(I,J)
	      ELSE
	        MODSQ(I,J)=0.
	      ENDIF
	   END DO
	END DO
	
	RETURN
	END
C********************************************************************
C*****************************************************************************
C Swap the two bytes of integer*2 values.
C
C IN   : Input/Output array
C NCAR : Number of INTEGER*2 to swap
c************************************************************
        SUBROUTINE SWAP (IN, NCAR)
	INTEGER*2 IN(*), AUXI2
	INTEGER*4 NCAR
	LOGICAL*1 LOW, AUXL1(2)
	EQUIVALENCE (AUXI2, AUXL1(1))
 
        DO I=1, NCAR
	 AUXI2=IN(I)
	 LOW=AUXL1(1)
C Swap
	 AUXL1(1)=AUXL1(2)
	 AUXL1(2)=LOW
	 IN(I)=AUXI2
	 END DO
	 RETURN
 
	 END
C*************************************************************
	SUBROUTINE CENTER_GRAV(IMAGE,NX,NY,IDIM,XC_GRAV,YC_GRAV)
	REAL*4 IMAGE(IDIM,*)
	REAL*4 XC_GRAV,YC_GRAV,SUM,SUMX,SUMY
	INTEGER*4 NX,NY

	
C Add up all the coordinates:
	SUMX=0.
	SUM=0
	DO J=1,NY
	DO I=1,NX
	  SUMX=SUMX+FLOAT(I)*IMAGE(I,J)
	  SUM=SUM+IMAGE(I,J)
	END DO
	END DO
	IF(SUM.NE.0)THEN
	  XC_GRAV=SUMX/SUM
        ELSE
	  XC_GRAV=0.
	ENDIF

C Add up all the coordinates:
	SUMY=0.
	SUM=0.
	DO J=1,NY
	DO I=1,NX
	  SUMY=SUMY+FLOAT(J)*IMAGE(I,J)
	  SUM=SUM+IMAGE(I,J)
	END DO
	END DO
	IF(SUM.NE.0)THEN
	  YC_GRAV=SUMY/SUM
        ELSE
	  YC_GRAV=0.
	ENDIF

	RETURN
	END
C********************************************************************
	SUBROUTINE SNR_MODSQ(SNRM,MODSQ,NX1,NY1,IDIM)
        INTEGER*4 IDIM,NX1,NY1
        REAL*4 SNRM(IDIM,*),MODSQ(IDIM,*)
        DO 1 J=1,NY1
          DO 2 I=1,NX1
C Sigma**2 = Sum of x_i**2 / N - mean**2
           SNRM(I,J)=SNRM(I,J)-MODSQ(I,J)*MODSQ(I,J)
C SNR= modsq/sigma:
           WORK=MAX(SNRM(I,J),1.E-4)
           SNRM(I,J)=MAX(0.,MODSQ(I,J))/SQRT(WORK)
2         CONTINUE
1       CONTINUE

        RETURN
        END
C********************************************************************
C        INTEGER*2 FUNCTION JLP_AND(I1,I42)
        INTEGER FUNCTION JLP_AND(I1,I42)
	  INTEGER*4 I42
	  INTEGER*2 I1,I2,I3
	  I2=I42
	  CALL JLP_ANDSHORT(I1,I2,I3)
	  JLP_AND=I3
	END
C        INTEGER*2 FUNCTION JLP_OR(I1,I2)
       INTEGER FUNCTION JLP_OR(I1,I2)
	  INTEGER*2 I1,I2,I3
	  CALL JLP_ORSHORT(I1,I2,I3)
	  JLP_OR=I3
	END
C        INTEGER*2 FUNCTION JLP_BTEST(I1,I42)
        INTEGER FUNCTION JLP_BTEST(I1,I42)
	  INTEGER*4 I42
	  INTEGER*2 I1,I2,I3
	  I2=I42
	  CALL JLP_BTESTSHORT(I1,I2,I3)
	  JLP_BTEST=I3
	END
C        INTEGER*2 FUNCTION JLP_ISHFT(I1,I42)
        INTEGER FUNCTION JLP_ISHFT(I1,I42)
	  INTEGER*4 I42
	  INTEGER*2 I1,I2,I3
	  I2=I42
	  CALL JLP_SHFTSHORT(I1,I2,I3)
	  JLP_ISHFT=I3
	END

C++**************************************************************
C SNR_ESTIM
C To estimate mean and SNR with bins of NNFR frames
C
C  WARNING: This does not work with zero frequency 
C           (if this freqeunecy is set to unity...)
C--**************************************************************
        SUBROUTINE SNR_ESTIM(MODSQ1,SNRM1,NNFR,IFRAME)
        REAL OLD_SNRM,SUM1,SUMSQ1,MODSQ1,SNRM1
        REAL WORK,XSDT1,XSDT2,SNR1,SNR2,XM1,XM2
        INTEGER N1,NNFR,IFRAME
C Test for SNR computation:
	COMMON/TEST/OLD_SNRM,SUM1,SUMSQ1,N1
C Uses the current value of the sum MODSQ1
            WORK=(MODSQ1-OLD_SNRM)/FLOAT(NNFR)
C Saves old value in OLD_SNRM:
            OLD_SNRM=MODSQ1
C Computes sum of values and of squares: 
            SUM1=SUM1+WORK
            SUMSQ1=SUMSQ1+WORK*WORK
            N1=N1+1
C If more than one value, compute an estimate of the mean and variance:
            IF(N1.GT.1)THEN
              XM1=SUM1/FLOAT(N1)
              XSDT1=SUMSQ1/FLOAT(N1)-XM1*XM1
              XSDT1=SQRT(XSDT1) 
              SNR1=XM1/XSDT1
C Displays it:
              PRINT *,' XM1, XSDT1, SNR1 =',XM1,XSDT1,SNR1,' N1=',N1
C And compares these values with the mean and variance with only one elementary frame:
              XM2=MODSQ1/FLOAT(IFRAME)
              XSDT2=SNRM1/FLOAT(IFRAME)-XM2*XM2
              XSDT2=MAX(1.E-18,XSDT2)
              XSDT2=SQRT(XSDT2) 
              SNR2=XM2/XSDT2 
              PRINT *,' XM2, XSDT2, SNR2 =',XM2,XSDT2,SNR2,'IFR=',IFRAME
C             PRINT *,'MODSQ, SNRM=',MODSQ1,SNRM1
            ENDIF
         END

C********************************************************************
        include 'jlp_bispec1.for'
	include 'jlp_cover.for'
CC	include 'fft_jlp.for'
C	include 'fft_nag.for'
