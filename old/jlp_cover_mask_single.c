/********************************************************************
* Set of routines for uv-coverage, spectral and bispectral lists:
*   
* Contains:
* int COVERA_MASK(mask,nx_mask,ny_mask,ir,max_nclosure,nbeta,ngamma)
* static int couv_mask(mask,nxm,nym,ir,nbeta,ngamma,nbc_dim,nbc_offset)
* static int affect_mask(mask,nxm,nym,isx,isy,irs,nb,ng,nbc_dim,nbc_offset)
* int cover_mask_to_eric(bisp_list,spec_list,dimension_file,nbeta,ngamma)
* int modsq_to_eric(modsq,nx,ny,mod_ascii_file,nbeta)
* int bisp_to_2D_image(out_image,modsq,&nx_modsq,&ny_modsq,
*                      bisp,&nx_bisp,&nbeta,&ngamma)
* int bispec3(re,im,modsq,snrm,nx,ny,yce1,ir,nbeta,ngamma)
* int photon_corr(yce1,modsq,snrm,nx,ny,xphot,nbeta,ngamma,photon_correction)
* int photon_corr_mask(yce1,modsq,nx,ny,yce_dim,xphot,nbeta,ngamma)
* int rearrange_mask(yce1,ngamma,ydim1)
*
*
* FORTRAN interface:
* int COVER_NGT(ngt_val,index)
* int COVER_IXY(ixy1_val,ixy2_val,index)
* int COVER_NBCOUV(nb_val,index1,index2,ir)
* int COVER_KLM(klm_val,klm_index,ng_index)
*
* JLP
* Version 02-11-93
*******************************************************************/
#include <stdio.h>
#include <math.h>
#include <jlp_ftoc.h>

/*
#define DEBUG
*/

/* For ir = 25, nbmax = 980  and ngmax = 187566 
*  For ir = 30, nbmax = 1410 and ngmax = 388400
*  For ir = 35, nbmax = 1926 and ngmax = 724838   
*  For ir = 40, nbmax = 2512 and ngmax = 1233164 
*/
/*
#define IRMAX 25
#define NBMAX 980

#define IRMAX 30 
#define NBMAX 1410 

#define IRMAX 35 
#define NBMAX 1926 

#define IRMAX 40 
#define NBMAX 2512
*/

#define IRMAX 50 
#define NBMAX 3922 

static int *nbcouv, *ixy_1, *ixy_2, *ngt, *klm;
static float xr[NBMAX], xi[NBMAX];

/********************************************************************
* Subroutine COVERA_MASK
* To compute the frequencies of the uv coverage, 
* and the elements of the A matrix.
* (To solve eventually the equation A*X=Y, 
*   i.e., to invert the bispectral relations)
*
* Compute u-v coverage with the mask and within a disk of radius ir.
*
* Input:
*  ir: maximum radius of the uv-coverage
*  max_nclosure: maximum number of closure relations
*  mask[nx * ny]: frequency mask ( >=1. if frequency accessible, 0. otherwise) 
*
* Output:
*  NBETA: Number of elements of the spectral list (Number of columns of A)
*  NGAMMA: Number of elements of the bispectral list (Number of rows of A)
*
*********************************************************************/
int COVERA_MASK(mask,nx_mask,ny_mask,ir,max_nclosure,nbeta,ngamma)
float mask[];
int *nx_mask, *ny_mask;
int *ir, *max_nclosure, *nbeta, *ngamma;
{
/* max_nclosure: max number of closure relations per spectral term */
/* Limitation of the maximum number of closure relations
* (to simulate Knox-Thompson and/or accelerate computations...) */ 
int isize, nxm, nym, ir_max, nbc_dim, nbc_offset, iw1;
register int i;
int JLP_GVM();

/* JLP 94
 ir_max = IRMAX;
*/
ir_max = *ir;
if(ir_max > IRMAX)
   {printf(" COVERA_MASK/Fatal error: ir max = %d \n",IRMAX);
    exit(-1);
   }
nbc_dim = 2 * ir_max + 1; 
nbc_offset = ir_max + 1; 

nxm = *nx_mask;
nym = *ny_mask;
/* Check first that mask is correct: */
if(nxm < 2 * (*ir) || nym < 2 * (*ir))
  {
   printf(" covera_mask/Fatal error: mask is too small !!!\n");
   printf(" nxm = %d nym = %d ir = %d \n",nxm,nym,*ir);
   exit(-1);
  }
 
/* nbcouv( x from -IRMAX to IRMAX,  y from 0 to IRMAX ) */
/* JLP94 */
isize = (ir_max + 1) * nbc_dim * sizeof(int);
JLP_GVM(&nbcouv,&isize);
/* ixy( 1 for x; 2 for y,  nb from 0 to NBMAX ) */
isize = (NBMAX + 1) * sizeof(int);
JLP_GVM(&ixy_1,&isize);
JLP_GVM(&ixy_2,&isize);
JLP_GVM(&ngt,&isize);
/*JLP 94 */
for(i = 0; i < nbc_dim * (ir_max + 1); i++) nbcouv[i] = 0;
 
/* Computing the A matrix as generated by the uv-coverage 
   (defined only by IR for a full pupil) */

/* First call to compute bispectrum size NGMAX = ngamma: */
couv_mask(mask,nxm,nym,ir,nbeta,ngamma,nbc_dim,nbc_offset,*max_nclosure,1);

/* Allocation of memory for bispectrum: */
isize = 3 * (*ngamma) * sizeof(int);
JLP_GVM(&klm,&isize);

/* Second call to compute spectral and bispectral lists: */
couv_mask(mask,nxm,nym,ir,nbeta,ngamma,nbc_dim,nbc_offset,*max_nclosure,0);
 
printf(" covera/uv-coverage, IR = %d \n",*ir);
printf("  NBETA (spectral list) = %d \n",*nbeta);
printf("  NGAMMA (bispec. list) = %d \n",*ngamma);
 
/* Computing the number of closure relations for some values of NB: */
for ( i = 3; i < (*nbeta) + 1 ; i += 100)
  {
   iw1 = sqrt((double)(ixy_1[i] * ixy_1[i] + ixy_2[i] * ixy_2[i]));
   printf(" NB = %d irad=%d Closure relations: %d \n",
             i,iw1,ngt[i] - ngt[i - 1]);
  }
 
/* Free memory: */
JLP_FVM(&nbcouv);

return(0);
}
/*******************************************************************
* couv_mask defines the uv-coverage and the A matrix:
* Input:
* mask[nx * ny]: frequency mask ( >=1. if frequency accessible, 0. otherwise) 
* IR: maximum radius of the uv-coverage
* dimension_only: flag set to one if only bispectral list dimension is required
*
* Output:
* NBETA, NGAMMA: number of elements of the spectral and bispectral lists
*
* In common blocks (output): the uv-coverage is accessible from 2 sides:
*
* NBCOUV(I,J): uv-coverage (i.e. number of the spectral list for
*              the pixel(I,J) of the spectrum (I=0,J=0 for null frequency)
*
* IXY(1,I) and IXY(2,I) coordinates of the pixel number I in the spectral list
*              (this allows another entry for the uv-coverage)
*
*************************************************************************/
static int couv_mask(mask,nxm,nym,ir,nbeta,ngamma,nbc_dim,
                     nbc_offset,max_nclosure,dimension_only)
float mask[];
int nxm, nym, nbc_dim, nbc_offset, max_nclosure, dimension_only;
int *ir, *nbeta, *ngamma;
{
/* 
* nb: beta index, i.e. spectral list index
* ng: gamma index, i.e. bispectral list index
*/
int isize, ir2max, nb, ng;
int i, i2, j2, ii2, irs, icent;
register int j, ir2;
 
/* Coordinate of center of the mask: */
icent = nxm/2 + nxm * nym/2; 
 
/* Easy cases: */
/* First spectral value at (0,0) */
 nb = 0;
 i = 0; j = 0;
 if(mask[ i + icent + nxm * j] > 0.)
   {
   ixy_1[nb] = i; ixy_2[nb] = j;
   nbcouv[i + nbc_offset + nbc_dim * j] = nb;
   }
 
/* Second spectral value at (1,0), nb=1 */
 i = 1; j = 0;
 if(mask[ i + icent + nxm * j] > 0.)
   {
   nb++;
   ixy_1[nb] = i; ixy_2[nb] = j;
   nbcouv[i + nbc_offset + nbc_dim * j] = nb;
   }

/* Third spectral value at (0,1), nb=2 */
 i = 0; j = 1;
 if(mask[ i + icent + nxm * j] > 0.)
   {
   nb++;
   ixy_1[nb] = i; ixy_2[nb] = j;
   nbcouv[i + nbc_offset + nbc_dim * j] = nb;
   }
 
/* Reseting the total number of elements the  bispectral list */
 ng = 0;
 
/* Main loop: work with successive iterations on circles with
* increasing radii.
* Squared radius: IR2 = 2, 3, ... ,IR2MAX
*/
ir2max = *ir * *ir;
for ( ir2 = 2; ir2 <= ir2max; ir2++) 
  {
/* Searching for the couples (I,J) such as: I**2 + J**2 = IR2 with I>=J */
    for ( j = 0; j <= *ir; j++) 
      {
       j2 = j*j; 
       i2 = ir2 - j2;
       if ( i2 < j2) break;
         i = (int)sqrt((double)i2);
         ii2 = i * i;
/* Selecting the points defined by each couple (i,j) 
   such that (i*i + j*j= ir2): */
         if(ii2 == i2)
            {
              irs = (int)sqrt((double)ir2);
               affect_mask(mask,nxm,nym,i,j,irs,&nb,&ng,
                           nbc_dim,nbc_offset,max_nclosure,dimension_only);
/* Now use the symmetry relations: */
              if( i != j) 
                affect_mask(mask,nxm,nym,j,i,irs,&nb,&ng,
                           nbc_dim,nbc_offset,max_nclosure,dimension_only);
              if( j != 0) 
                affect_mask(mask,nxm,nym,-j,i,irs,&nb,&ng,
                           nbc_dim,nbc_offset,max_nclosure,dimension_only);
              if( i != j && j != 0) 
                affect_mask(mask,nxm,nym,-i,j,irs,&nb,&ng,
                           nbc_dim,nbc_offset,max_nclosure,dimension_only);
            }
      }
  }
 
/* NBETA: Total number of the spectral list (Number of columns of the X matrix)
* NGAMMA: Total number of the bispectral list (Number of rows of the X matrix)
* (Remember, we have to solve    A*X = Y) */
  *nbeta = nb;
  *ngamma = ng;

  return(0);
}
/*******************************************************************
* affect_mask:
* Gives a structure to the S group of the A matrix
* Input:
* ISX, ISY : coordinates
* IRS: radius
*
* Output:
* NB: index in the spectral list
* NG: index in the bispectral list
********************************************************************/
static int affect_mask(mask,nxm,nym,isx,isy,irs,nb,ng,
                       nbc_dim,nbc_offset,max_nclosure,dimension_only)
float mask[];
int nxm, nym, nbc_dim, nbc_offset, max_nclosure, dimension_only;
int isx, isy, irs, *nb, *ng; 
{ 
int nbs, nbk, nbr, itx, ity, icent;
register int nbq, iklm;

/* Coordinate of center of the mask: */
icent = nxm/2 + nxm * nym/2; 
 
/* First condition: input point has to be accessible */
  if(mask[isx + icent + isy * nxm] <= 0.) return(-1);

/* If so, record the new point of the uv coverage (spectral list): */
 (*nb)++;
 ixy_1[*nb] = isx; ixy_2[*nb] = isy;
 nbcouv[isx + nbc_offset + nbc_dim * isy] = *nb;

/* Searching for the couples associated with the point NBS=NB
* Generating the bispectral list and building the rows of the A matrix:
*/
 nbs = *nb;
 
/* Loop on all the possible points (Q): */
 iklm = 3 * (*ng);
 for( nbq = 1; nbq < nbs; nbq++)
  { 
/* JLP 94: add an exit test when maximum number of closure relations
has been found (to simulate Knox-Thompson and/or accelerate computations...) */ 
   if((*ng - ngt[(*nb) -1]) == max_nclosure) break;

/* Coordinates of the vector T = S - Q */
   itx = isx - ixy_1[nbq];
   ity = isy - ixy_2[nbq];
 
/* Work within the circle of radius IRS, so we can a priori reject
* the points outside the window [-IRS,+IRS]:
*/
   if(itx >= -irs && itx <= irs && ity >= -irs && ity <= irs)
      {
       if(ity > 0 || ( ity == 0 && itx >= 0))
          {
/* Case number 1 (which could be : k=t, l=q, k+l=s) */

/* t should be accessible too: */
            if(mask[itx + icent + ity * nxm] > 0.)
            {
              nbk = nbcouv[ itx + nbc_offset + ity * nbc_dim];
 
/* We select this couple (U,V) if the vector NBK is in [0,NBQ] */
              if( nbk != 0 && nbk <= nbq)
                 {
/* Add new k,l,m coordinates if more than dimension is wanted */
                 if(!dimension_only)
                   {
                   klm[iklm] = nbk; 
                   iklm++;
                   klm[iklm] = nbq; 
                   iklm++;
                   klm[iklm] = nbs;
                   iklm++;
                   }
                 (*ng)++;
                 }
            }
          }
      else
          { 
/* Case number 2 (which could be : r=-t, s=s, r+s=m=q) */
/* r should be accessible too: */
            if(mask[-itx + icent - ity * nxm] > 0.)
            {
             nbr = nbcouv[ -itx + nbc_offset - ity * nbc_dim];
/* We select this couple (R,S) if the vector NBR is in [0,NBS] */
              if( nbr != 0 && nbr <= nbs)
                  {
/* Add new k,l,m coordinates if more than dimension is wanted */
                  if(!dimension_only)
                     {
                     klm[iklm] = nbr; 
                     iklm++;
                     klm[iklm] = nbs; 
                     iklm++;
                     klm[iklm] = nbq;
                     iklm++;
                     }
                  (*ng)++;
                  }
            }
/* Nota: we can only have L=NBS or M=NBS (never K=NBS) */
          }
      } 

/* End of loop on nbq */
}
 
/* NGT(NB) is the number of the last U,V couple of the group NB=NBS=S: */
   ngt[nbs] = *ng;

 return(0);
}
/*******************************************************************
* Output spectral, bispectral list in Eric's format
*
* Input:
* bisp_list, spec_list, dimension_file: file names for bispectral list
*                                       spectral list, and dimension file
*
* Output:
*******************************************************************/
int cover_mask_to_eric(bisp_list,spec_list,dimension_file,nbeta,ngamma)
char *bisp_list, *spec_list, *dimension_file;
int *nbeta, *ngamma;
{
FILE   *fp;
register int ng, nb, nr, j, iklm;
int n_networks = 1;

/***** Output of bispectral list in a file ********************/
if ((fp = fopen(bisp_list,"w")) == NULL)
   {
   printf(" cover_mask_to_eric/Fatal error opening output file: %s \n",
            bisp_list);
   exit(-1);
   }

iklm = 0;
for (ng = 0; ng < *ngamma; ng++)
  {
  fprintf(fp,"%d\n",ng);

/* Bispectral redundancy (red_bispect) : */
/*
  for (j = 0; j < n_networks; j++)  fprintf(fp,"%d ",red_bispect[ng][j]);
*/
  for (nr = 0; nr < n_networks; nr++)  fprintf(fp,"%d ",1);

/* Spectral indices k, l, m, of the three components of bispectral term: 
  (I subtract one here to the coordinates to be compatible with Eric. 
  This is because (nb-1) is stored as spectral index instead of nb...)
 */
  fprintf(fp,"\n%d %d %d\n",klm[iklm]-1,klm[iklm+1]-1,klm[iklm+2]-1);
  iklm = iklm + 3;
  }
fclose(fp);

/***** Output of spectral list in a file ********************/
if ((fp = fopen(spec_list,"w")) == NULL)
   {
   printf(" cover_mask_to_eric/Fatal error opening output file: %s \n",
            spec_list);
   exit(-1);
   }

for (nb = 1; nb <= *nbeta; nb++)
  {
  fprintf(fp,"%d ",nb-1);
  fprintf(fp,"(%d,%d) ",ixy_1[nb],ixy_2[nb]);

/* Spectral redundancy: */
/*
  fprintf(fp,"%d ",red_spect[nb]);
*/
  fprintf(fp,"%d ",1);

  fprintf(fp,"%d\n",ngt[nb]);

  }

/* As the following is not understood (and not used either), I remove it: */
#ifdef UNDERSTAND
for (nr = 0; nr < n_networks; nr++)
  {
  fprintf(fp,"%d\n",nr);
  for (nb = 1; nb <= *nbeta; nb++)
    {
    fprintf(fp,"  %-d:\t",nb-1);
/* Redundancy, caracteristic function (for FTO) ... */
/*
    fprintf(fp,"(%d-%d)\t",u_v_res[nr][nb][2],u_v_res[nr][nb][1]);
    fprintf(fp,"%d\n",u_v_res[nr][nb][0]);
*/
    fprintf(fp,"(%d-%d)\t",1,1);
    fprintf(fp,"%d\n",1);
    }
  }
#endif

fclose(fp);

/***** Output of dimensions ****************************/
if ((fp = fopen(dimension_file,"w")) == NULL)
   {
   printf(" cover_mask_to_eric/Fatal error opening output file: \n",
            dimension_file);
   exit(-1);
   }

/* Number of networks */
fprintf(fp,"%d\n",n_networks);

/* Number of telescopes per network */
for (nr = 0; nr < n_networks; nr++) fprintf(fp,"%d ",1);

/* Number of spectral frequencies */
fprintf(fp,"\n%d\n",*nbeta);

/* Number of bispectral bi-frequencies */
fprintf(fp,"%d\n",*ngamma);

fclose(fp);

return(0);
}
/*******************************************************************
* Output modulus to Eric's format ASCII file: 
*
* Input:
* mod_ascii_file: file name for modulus 
*
* Output:
*******************************************************************/
int modsq_to_eric(modsq,nx,ny,mod_ascii_file,nbeta)
float *modsq;
int *nx, *ny, *nbeta;
char *mod_ascii_file;
{
FILE   *fp;
float work;
int icent, inull;
register int nb;

/* Coordinate of the center: */
icent = (*nx)/2 + (*nx) * (*ny)/2; 
 
/***** Output of modulus to a file ********************/
if ((fp = fopen(mod_ascii_file,"w")) == NULL)
   {
   printf(" modsq_to_eric/Fatal error opening output file: %s \n",
            mod_ascii_file);
   exit(-1);
   }

inull = 0;
for (nb = 0; nb < *nbeta; nb++)
 {
  work = modsq[ ixy_1[nb] + icent + (*nx) * ixy_2[nb] ];
/* Compute square root: */
  if(work < 0)
    {
     work = 0.;
     inull++;
    }
  else
     work = sqrt((double)work);

  fprintf(fp,"%f\n",work);
 }

fclose(fp);

/* Display warning message to alert the user... */
if(inull)printf("mod_to_eric/Warning: %d negative values in modsq !!!\n",inull);

return(0);
}
/*******************************************************************
* Output bispectrum phasor to Eric's format ASCII file: 
*
* Input:
* bisp_ascii_file: file name for output bispectrum 
*
* Output:
*******************************************************************/
int bisp_to_eric(bisp,idim,bisp_ascii_file,ngamma)
float *bisp;
int *idim, *ngamma;
char *bisp_ascii_file;
{
FILE   *fp;
float r0, i0, work;
int inull;
register int ng;

/***** Output of bispectrum to a file ********************/
if ((fp = fopen(bisp_ascii_file,"w")) == NULL)
   {
   printf(" bisp_to_eric/Fatal error opening output file: %s \n",
            bisp_ascii_file);
   exit(-1);
   }

inull = 0;
for (ng = 0; ng < *ngamma; ng++)
 {
  r0 = bisp[ng]; i0 = bisp[ng + (*idim)];
  
/* Compute modulus: */
  work = r0*r0 + i0*i0;
  if(work == 0.)
    {
     inull++;
    }
  else
    {
     work = sqrt((double)work);
     r0 /= work; i0 /= work;
    }

  fprintf(fp,"%f %f\n",r0,i0);
 }

fclose(fp);

/* Display warning message to alert the user... */
if(inull)printf("bisp_to_eric/Warning: %d null values in bispectrum!\n",inull);

return(0);
}
/*******************************************************************
* bispec3 
* Same as bispec1, but newer version.
* Sum of full bispectrum terms (amplitude and phase)
* Reads a spectrum from an real image (from observations)
*
* Computes the bispectrum and spectrum lists from RE and IM
* already computed before calling this routine.
*
* Integrates the squared modulus of the spectrum and
* the phase factor of the bispectrum. 
* Does not correct from photon noise effects.
*
* Input:
* RE(NX,NY) (please note that idim has disappeared...)
* IM(NX,NY)
*
* Output:
* MODSQ: Sum of the modulus squared
* YCE1: phase factor of the bispectrum (real and imaginary)
* YCE1(.,3): sum of square real parts of the bispectrum
* YCE1(.,4): sum of square imaginary parts of the bispectrum
********************************************************************/
int bispec3(re,im,modsq,snrm,nx,ny,yce1,ir,nbeta,ngamma)
double re[], im[];
float modsq[], snrm[], yce1[];
long *nx, *ny, *ir, *nbeta, *ngamma;
{
float w1, work;
int k1, k2, k3;
float wr1, wr2, wr3, wi1, wi2, wi3;
float aar, aai, work1, work2; 
register int ng, i, j, nb, yce_ng, iklm;

#ifdef DEBUG
/* Check the FFT (zero frequency is at (0,0)): */
w1 = re[0]*re[0] + im[0]*im[0];
w1 = sqrt((double)w1);
printf(" xphot1 = %f \n",w1);
#endif
 
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list. 
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       i = ((ixy_1[nb] + *nx) % *nx) 
           + (*nx * ((ixy_2[nb] + *ny) % *ny)); 
       xr[nb] = re[i];
       xi[nb] = im[i];
     }
 
/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* (No correction of photon noise)
*/
yce_ng = 0;
iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
     wr1 = xr[k1]; wr2 = xr[k2]; wr3 = xr[k3];
     wi1 = xi[k1]; wi2 = xi[k2]; wi3 = xi[k3];
/*  CC1=XC1*XC2*CONJG(XC3): AAR*WR3+AAI*WI3 */
     aar = wr1 * wr2 - wi1 * wi2;
     aai = wr2 * wi1 + wr1 * wi2;
     work1 = aar * wr3 + aai * wi3;
     work2 = aai * wr3 - aar * wi3;
     yce1[yce_ng] += work1;
     yce_ng++;
     yce1[yce_ng] += work2;

/* Estimation of the noise with the sum of squares: */
     yce_ng++;
     yce1[yce_ng] += work1*work1;
     yce_ng++;
     yce1[yce_ng] += work2*work2;
     yce_ng++;
  }
 
/****************************************************************/
/* Squared modulus for the output (not corrected for photon noise) */
    for( i = 0; i < *nx * *ny; i++)
       {
        w1 = re[i]*re[i] + im[i]*im[i];
        modsq[i] += w1;
        snrm[i] += (w1 * w1);
       }
 
 return(0);
}
/*******************************************************************
* bispec_1D
* From bispec3, 1-D version for spectra
* Sum of full bispectrum terms (amplitude and phase)
* Reads a spectrum from an real image (from observations)
*
* Computes the bispectrum and spectrum lists from RE and IM
* already computed before calling this routine 
* (Fourier spectra along the lines).
*
* Integrates the squared modulus of the spectrum and
* the phase factor of the bispectrum. 
*
* Does not correct from photon noise effects. 
*
* Input:
* RE(NX,NY) (please note that idim has disappeared...)
* IM(NX,NY)
*
* Output:
* MODSQ: Sum of the modulus squared
* YCE1: phase factor of the bispectrum (real and imaginary)
* YCE1(.,3): sum of square real parts of the bispectrum
* YCE1(.,4): sum of square imaginary parts of the bispectrum
********************************************************************/
int bispec_1D(re,im,modsq,snrm,nx,ny,yce1,ir,nbeta,ngamma)
double re[], im[];
float modsq[], snrm[], yce1[];
long *nx, *ny, *ir, *nbeta, *ngamma;
{
float w1, work;
int k1, k2, k3;
float wr1, wr2, wr3, wi1, wi2, wi3;
float aar, aai, work1, work2; 
register int ng, i, j, nb, yce_ng, iklm;

#ifdef DEBUG
/* Check the FFT in the middle line
   (zero frequency is at (0,iy) for each line): */
i = 0 + nx * ny /2;
w1 = re[i]*re[i] + im[i]*im[i];
w1 = sqrt((double)w1);
printf(" xphot1(middle line) = %f \n",w1);
#endif
 
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list. 
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       i = ((ixy_1[nb] + *nx) % *nx) 
           + (*nx * ((ixy_2[nb] + *ny) % *ny)); 
       xr[nb] = re[i];
       xi[nb] = im[i];
     }
 
/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* (No correction of photon noise)
*/
yce_ng = 0;
iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
     wr1 = xr[k1]; wr2 = xr[k2]; wr3 = xr[k3];
     wi1 = xi[k1]; wi2 = xi[k2]; wi3 = xi[k3];
/*  CC1=XC1*XC2*CONJG(XC3): AAR*WR3+AAI*WI3 */
     aar = wr1 * wr2 - wi1 * wi2;
     aai = wr2 * wi1 + wr1 * wi2;
     work1 = aar * wr3 + aai * wi3;
     work2 = aai * wr3 - aar * wi3;
     yce1[yce_ng] += work1;
     yce_ng++;
     yce1[yce_ng] += work2;

/* Estimation of the noise with the sum of squares: */
     yce_ng++;
     yce1[yce_ng] += work1*work1;
     yce_ng++;
     yce1[yce_ng] += work2*work2;
     yce_ng++;
  }
 
/****************************************************************/
/* Squared modulus for the output (not corrected for photon noise) */
    for( i = 0; i < *nx * *ny; i++)
       {
        w1 = re[i]*re[i] + im[i]*im[i];
        modsq[i] += w1;
        snrm[i] += (w1 * w1);
       }
 
 return(0);
}
/**************************************************************** 
* Photon noise correction: (called by decode_car2 )
*
*  Input:
* modsq[]: mean normalized squared modulus
* xphot: mean photon flux per frame 
*
* Photon noise correction (cf JOSA 2, 14, Wirnitzer):
* (When spectrum normalized to one in the center)
* <i(u)>**2 = E(D...)/N**2 - 1/N
*
* <i(3)(u,v)> = E(D(3)(u,v)/N**3 - E(D(2)(u)/N**2)/N - E(D(2)(v)... +2/N**3)
*
*****************************************************************/
int photon_corr(yce1,modsq,snrm,nx,ny,xphot,nbeta,ngamma,photon_correction)
float yce1[], modsq[], snrm[], *xphot;
int *nx, *ny, *nbeta, *ngamma, *photon_correction;
{
float xphot2, xphot3, xphot4, xphot6;
float norm_fft, norm_fft2, norm_fft3, norm_fft4, norm_fft6;
float w1, w2, xphot1, work;
float wm1, wm2, wm3, work1, work2;
int ii, jj, k1, k2, k3, iix, iiy;
register int i, j, nb, ng, yce_ng, iklm;

norm_fft = sqrt((double)(*nx * *ny));
norm_fft2 = *nx * *ny;
norm_fft3 = norm_fft2 * norm_fft;
norm_fft4 = norm_fft2 * norm_fft2;
norm_fft6 = norm_fft3 * norm_fft3;

/* Normalizes FFT (for compatibility with FFT_2D instead of FFT_2D_FAST...*/
  for( i = 0; i < *ny * *nx; i++) 
     {
     modsq[i] *= norm_fft2;
     snrm[i] *= norm_fft4;
     }

   yce_ng = 0;
   for(ng = 0; ng < *ngamma; ng++)
     {
     yce1[yce_ng] *= norm_fft3;
     yce_ng++; 
     yce1[yce_ng] *= norm_fft3;
     yce_ng++; 
     yce1[yce_ng] *= norm_fft6;
     yce_ng++; 
     yce1[yce_ng] *= norm_fft6;
     yce_ng++; 
     }

/*******************************************************/
/* Return if no correction is needed: */
if(!*photon_correction) return(0);

/*******************************************************/
/* First the bispectrum */

  xphot2 = *xphot * *xphot;
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list.
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       iix = ((ixy_1[nb] + *nx) % *nx);
       iiy = ((ixy_2[nb] + *ny) % *ny);
/* Here xr is used to store the mean normalized square modulus: */
       xr[nb] = modsq[iix + iiy * *nx];
     }

/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* and correction from photon noise effects:
*/
 w2 = 2. *  *xphot;
 yce_ng = 0;
 iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
/* Photon noise correction 
*/
     work1 = - (xr[k1] + xr[k2] + xr[k3]) + w2;
     yce1[yce_ng] += work1;

/* Estimation of the noise with the sum of squares: */
     yce_ng++; yce_ng++;
     yce1[yce_ng] -= work1*work1;
     yce_ng++; yce_ng++;
  }

/*******************************************************/
/* Then correcting the squared modulus: */
  xphot4 = xphot2 * xphot2;
  for( i = 0; i < *ny * *nx; i++) 
     {
/* Photon noise correction: (biased_sq = xphot + xphot_sq * unbiased_sq)*/
      modsq[i] -= *xphot;
/* Normalization for compatibility with previous computations: */
      modsq[i] /= xphot2;
      snrm[i] /= xphot4;
    }

/*******************************************************/
xphot3 = *xphot * *xphot * *xphot;
xphot6 = xphot3 * xphot3;
yce_ng = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     yce1[yce_ng] /= xphot3;
     yce_ng++;
     yce1[yce_ng] /= xphot3;
     yce_ng++;
     yce1[yce_ng] /= xphot6;
     yce_ng++;
     yce1[yce_ng] /= xphot6;
     yce_ng++;
 }

return(0);
}
/*******************************************************/
int rearrange_mask(yce1,ngamma,ydim1)
float yce1[];
int *ngamma, *ydim1;
{
int isize, ydim;
register int ng, yce_ng;
float *work;

ydim = *ydim1;
isize = 4 * ydim * sizeof(float);
JLP_GVM(&work,&isize);

/* Erases work array: */
for(ng = 0; ng < 4 * ydim; ng++) work[ng] = 0.; 

/* Transfer to temporary array: */
yce_ng = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     work[ng] = yce1[yce_ng];
     yce_ng++;
     work[ng + ydim] = yce1[yce_ng];
     yce_ng++;
     work[ng + 2 * ydim] = yce1[yce_ng];
     yce_ng++;
     work[ng + 3 * ydim] = yce1[yce_ng];
     yce_ng++;
 }

/* Transfer back to yce1: */
for(ng = 0; ng < 4 * ydim; ng++) yce1[ng] = work[ng]; 

JLP_FVM(&work);
return(0);
}
/**************************************************************** 
* Photon noise correction (Called by phot_noise_mask):
*
*  Input:
* modsq[]: mean normalized squared modulus
* xphot: mean photon flux per frame 
* yce1[]: bispectrum (arranged "normaly", and thus different
*         from arrangment needed by photon_corr...)
*
* Photon noise correction (cf JOSA 2, 14, Wirnitzer):
* (When spectrum normalized to one in the center)
* <i(u)>**2 = E(D...)/N**2 - 1/N
*
* <i(3)(u,v)> = E(D(3)(u,v)/N**3 - E(D(2)(u)/N**2)/N - E(D(2)(v)... +2/N**3)
*****************************************************************/
int photon_corr_mask(yce1,modsq,nx,ny,yce_dim,xphot,nbeta,ngamma)
float yce1[], modsq[], *xphot;
int *nx, *ny, *yce_dim, *nbeta, *ngamma;
{
float xphot2;
float w1, w2, xphot1, work;
float wm1, wm2, wm3, work1, work2;
int ii, jj, k1, k2, k3, iix, iiy, ixc;
register int i, j, nb, ng, iklm;

/*******************************************************/
/* First the bispectrum */

  xphot2 = *xphot * *xphot;
/* IXY(1,NB) and IXY(2,NB) are the X,Y coordinates of the
* element NB of the spectral list.
* As they (i.e. IXY) can be negative, and that zero frequency is at (0,0),
* we do the following transformation:
*/
  for(nb = 0; nb <= *nbeta; nb++)
     {
       iix = ((ixy_1[nb] + *nx) % *nx);
       iiy = ((ixy_2[nb] + *ny) % *ny);
/* Here xr is used to store the mean (not normalized) square modulus: */
       xr[nb] = modsq[iix + iiy * *nx];
       if(nb < 4) printf(" nb = %d iix, iiy: %d %d \n",nb,iix,iiy);
       if(nb < 4) printf(" xr = %f \n",xr[nb]);
     }

/****************************************************************/
/* Phase factor of the bispectrum (with bispectral list):
* and correction from photon noise effects:
*/
 w2 = 2. *  *xphot;
 iklm = 0;
for(ng = 0; ng < *ngamma; ng++)
 {
     k1 = klm[iklm]; iklm++;
     k2 = klm[iklm]; iklm++;
     k3 = klm[iklm]; iklm++;
/* JLP94*/
     if(ng < 4) printf(" ng = %d k, l, m: %d %d %d \n",ng,k1,k2,k3);
     if(ng < 4) printf(" xr1, xr2, xr3 %f %f %f \n",xr[k1],xr[k2],xr[k3]);
/* Photon noise correction 
*/
     work1 = - (xr[k1] + xr[k2] + xr[k3]) + w2;
/* JLP94*/
     if(ng < 4) printf(" ng= %d corr= %f \n",ng,work1);
     yce1[ng] += work1;
/* Phase factor: */
     w1 = yce1[ng]*yce1[ng] + yce1[ng + *yce_dim] * yce1[ng + *yce_dim];
     if(w1 > 0) 
       {
       w1 = sqrt((double)w1);
       yce1[ng] /= w1;
       yce1[ng + *yce_dim] /= w1;
       }

  }

/*******************************************************/
/* Then correcting the squared modulus: */
/* (Normalization to obtain unity in the center (zero frequency is at 0,0 here)) */
  w2 = modsq[0] - *xphot;
  for( i = 0; i < *ny * *nx; i++) 
     {
/* Photon noise correction: (biased_sq = xphot + xphot_sq * unbiased_sq)*/
      modsq[i] -= *xphot;
/* Normalization for compatibility with previous computations: */
      modsq[i] /= w2;
    }

return(0);
}
/***************************************************************
*
* Compute bispectrum slice:
* (Called by bisp_to_image.c)
*
* bisp(u,v) = bisp((u_1,u_2),(v_1,v_2)) 
* bisp(u,v) = spec(u) * spec(v) * spec(-u-v) 
* bisp(u,v) = spec(u_1,u_2) * spec(v_1,v_2) * spec(-u_1-v_1,-u_2-v_2) 
* Here we take u_2 = v_1 = 0
* bisp(u,v) = spec(u_1,0) * spec(0,v_2) * spec(-u_1,-v_2) 
* Hence we display the image bisp(u_1,0,0,v_2), 
* which is a function of the two coordinates u_1 and v_2
*
* iopt: option set to zero if real part of bispectrum has to be output,
*                     one if imaginary part ...
*                     two if SNR ...
****************************************************************/
int bisp_to_2D_image(out_image,modsq,nx,ny,bisp,nx_bisp,nbeta,ngamma,iopt)
float *out_image, *modsq, *bisp;
int *nx, *ny, *nx_bisp, *nbeta, *ngamma, *iopt;
{
float modsq_0, bisp_0;
register int i, j, iklm, ng;
int icent, kk, ll, mm;

/* If you want to check that all pixels are scanned in this routine: 
replace 0 by any arbitrary number:  */
for(i = 0; i < (*nx)*(*ny); i++) out_image[i] = 0.;

/* Coordinate of the center: */
icent = (*nx)/2 + (*nx) * (*ny)/2; 

/* Normalization constants: */
modsq_0 = modsq[icent]; 
printf(" Normalizing the input squared modulus by dividing by %f\n",modsq_0);
bisp_0 = pow((double)modsq_0,1.5);
printf(" Normalizing the input bispectrum by dividing by %f\n",bisp_0);
if(modsq_0 == 0 || bisp_0 == 0) 
 {
 printf("bisp_to_2D_image/Fatal error, normalization constant is null\n");
 printf(" modsq_0 = %f, bisp_0 = %f\n",modsq_0,bisp_0);
 exit(-1);
 }
 
/* X and Y axes correspond to the normalized power spectrum: 
* X axis, i.e., v_2=0:
* bisp(u,v) = spec(u_1,0) * spec(0,0) * spec(-u_1,0) = |spec(u_1,0)|**2 
* Y axis, i.e., u_1=0:
* bisp(u,v) = spec(0,0) * spec(0,v_2) * spec(0,-v_2) = |spec(0,v_2)|**2 
*/

/* X axis:  (at the centre of out_image) */
for(i = 0; i < *nx; i++) 
  out_image[i + (*nx) * (*ny)/2] = modsq[i + (*nx) * (*ny)/2] / modsq_0;

/* Y axis:  (at the centre of out_image) */
for(j = 0; j < *ny; j++) 
  out_image[(*nx)/2 + (*nx) * j] = modsq[(*nx)/2 + (*nx) * j] / modsq_0;


/* General case: */
iklm = 0;
for (ng = 0; ng < *ngamma; ng++)
  {
/* Spectral indices k, l, m, of the three components of bispectral term:
*/
   kk = klm[iklm]; iklm++;
   ll = klm[iklm]; iklm++;
   mm = klm[iklm]; iklm++;
   if(ixy_2[kk] == 0 && ixy_1[ll] == 0)
     {
       i = ixy_1[kk];
       j = ixy_2[ll];
       out_image[i + icent + (*nx) * j] = bisp[ng + (*ngamma)*(*iopt)] / bisp_0;
     }
  }


return(0);
}
/***************************************************************
*
* Interface to Fortran programs
* Output internal static arrays
*
****************************************************************/

/********************************************
* Fortran array NGT(NBMAX)
* Index: 1 to NBMAX (but c compatible on Feb 2nd 1994)
********************************************/
int COVER_NGT(ngt_val,index)
int *ngt_val, *index;
{
*ngt_val = ngt[*index];
return(0);
}
/********************************************
* Fortran array IXY(2,NULL:NBMAX)
* Second index: like c programs
********************************************/
int COVER_IXY(ixy1_val,ixy2_val,index)
int *ixy1_val, *ixy2_val, *index;
{
*ixy1_val = ixy_1[*index];
*ixy2_val = ixy_2[*index];
return(0);
}
/********************************************
* Fortran array NBCOUV(-IRMAX:IRMAX,NULL:IRMAX)
* Indices: (like c programs) 
********************************************/
int COVER_NBCOUV(nb_val,index1,index2,ir)
int *nb_val, *index1, *index2, *ir;
{
int nbc_dim, nbc_offset;

nbc_dim = 2 * (*ir) + 1; 
nbc_offset = (*ir) + 1; 

*nb_val = nbcouv[(*index1) + nbc_offset + nbc_dim * (*index2)];
return(0);
}
/*******************************************
* Fortran array KLM(3,NGMAX)
* Input indices: 1 to 3 and 1 to NGMAX
* Output index: klm_val from 0 to NBMAX 
*******************************************/
int COVER_KLM(klm_val,klm_index,ng_index)
int *klm_val, *klm_index, *ng_index;
{

*klm_val = klm[(*ng_index - 1) * 3 + (*klm_index - 1)];

return(0);
}
/********************************************************************
* Subroutine COVERA_MASK_1D
* To compute the frequencies of the uv coverage, 
* and the elements of the A matrix.
* (To solve eventually the equation A*X=Y, 
*   i.e., to invert the bispectral relations)
*
* Compute u-v coverage with the mask and within a segment of length 2*ir.
*
* Input:
*  ir: maximum radius of the uv-coverage
*  max_nclosure: maximum number of closure relations
*  mask[nx]: frequency mask ( >=1. if frequency accessible, 0. otherwise) 
*
* Output:
*  NBETA: Number of elements of the spectral list (Number of columns of A)
*  NGAMMA: Number of elements of the bispectral list (Number of rows of A)
*
*********************************************************************/
int COVERA_MASK_1D(mask,nx_mask,ir,max_nclosure,nbeta,ngamma)
float mask[];
int *nx_mask, *ir, *max_nclosure, *nbeta, *ngamma;
{
/* max_nclosure: max number of closure relations per spectral term */
/* Limitation of the maximum number of closure relations
* (to simulate Knox-Thompson and/or accelerate computations...) */ 
int isize, nxm, ir_max, iw1;
register int i;
int JLP_GVM();

/* JLP 94
 ir_max = IRMAX;
*/
ir_max = *ir;
if(ir_max > IRMAX)
   {printf(" COVERA_MASK_1D/Fatal error: ir max = %d \n",IRMAX);
    exit(-1);
   }

nxm = *nx_mask;
/* Check first that mask is correct: */
if(nxm < 2 * (*ir) )
  {
   printf(" covera_mask/Fatal error: mask is too small !!!\n");
   printf(" nxm = %d ir = %d \n",nxm,*ir);
   exit(-1);
  }
 
/* nbcouv( x from 0 to IRMAX ) */
/* JLP94 */
isize = (ir_max + 1) * sizeof(int);
JLP_GVM(&nbcouv,&isize);
/* ixy_1 for x;  nb from 0 to NBMAX ) */
isize = (NBMAX + 1) * sizeof(int);
JLP_GVM(&ixy_1,&isize);
JLP_GVM(&ngt,&isize);
/*JLP 94 */
for(i = 0; i < (ir_max + 1); i++) nbcouv[i] = 0;
 
/* Computing the A matrix as generated by the uv-coverage 
   (defined only by IR for a full pupil) */

/* First call to compute bispectrum size NGMAX = ngamma: */
couv_mask_1D(mask,nxm,ir,nbeta,ngamma,*max_nclosure,1);

/* Allocation of memory for bispectrum: */
isize = 3 * (*ngamma) * sizeof(int);
JLP_GVM(&klm,&isize);

/* Second call to compute spectral and bispectral lists: */
couv_mask_1D(mask,nxm,ir,nbeta,ngamma,*max_nclosure,0);
 
printf(" covera/uv-coverage, IR = %d \n",*ir);
printf("  NBETA (spectral list) = %d \n",*nbeta);
printf("  NGAMMA (bispec. list) = %d \n",*ngamma);
 
/* Computing the number of closure relations for some values of NB: */
for ( i = 3; i < (*nbeta) + 1 ; i += 100)
  {
   iw1 = sqrt((double)(ixy_1[i] * ixy_1[i]));
   printf(" NB = %d irad=%d Closure relations: %d \n",
             i,iw1,ngt[i] - ngt[i - 1]);
  }
 
/* Free memory: */
JLP_FVM(&nbcouv);

return(0);
}
/*******************************************************************
* couv_mask_1D defines the uv-coverage and the A matrix:
* Input:
* mask[nx]: frequency mask ( >=1. if frequency accessible, 0. otherwise) 
* IR: maximum radius of the uv-coverage
* dimension_only: flag set to one if only bispectral list dimension is required
*
* Output:
* NBETA, NGAMMA: number of elements of the spectral and bispectral lists
*
* In common blocks (output): the uv-coverage is accessible from 2 sides:
*
* NBCOUV(I,J): uv-coverage (i.e. number of the spectral list for
*              the pixel(I,J) of the spectrum (I=0,J=0 for null frequency)
*
* IXY(1,I) X-coordinate of the pixel number I in the spectral list
*              (this allows another entry for the uv-coverage)
*
*************************************************************************/
static int couv_mask_1D(mask,nxm,ir,nbeta,ngamma,
                     max_nclosure,dimension_only)
float mask[];
int nxm, max_nclosure, dimension_only;
int *ir, *nbeta, *ngamma;
{
/* 
* nb: beta index, i.e. spectral list index
* ng: gamma index, i.e. bispectral list index
*/
int isize, nb, ng, icent;
register int i;
 
/* Coordinate of center of the mask: */
icent = nxm/2; 
 
/* Easy cases: */
/* First spectral value at (0) */
 nb = 0;
 i = 0; 
 if(mask[i + icent] > 0.)
   {
   ixy_1[nb] = i; 
   nbcouv[i] = nb;
   }
 
/* Second spectral value at (1), nb=1 */
 i = 1; 
 if(mask[i + icent] > 0.)
   {
   nb++;
   ixy_1[nb] = i;
   nbcouv[i] = nb;
   }

/* Reseting the total number of elements the  bispectral list */
 ng = 0;
 
/* Main loop: 
*/
for ( i = 2; i <= *ir; i++) 
  {
    affect_mask_1D(mask,nxm,i,&nb,&ng,max_nclosure,dimension_only);
  }
 
/* NBETA: Total number of the spectral list (Number of columns of the X matrix)
* NGAMMA: Total number of the bispectral list (Number of rows of the X matrix)
* (Remember, we have to solve    A*X = Y) */
  *nbeta = nb;
  *ngamma = ng;

  return(0);
}
/*******************************************************************
* affect_mask_1D:
* Gives a structure to the S group of the A matrix
* Input:
* ISX, ISY : coordinates
* IRS: radius
*
* Output:
* NB: index in the spectral list
* NG: index in the bispectral list
********************************************************************/
static int affect_mask_1D(mask,nxm,isx,nb,ng,
                       max_nclosure,dimension_only)
float mask[];
int nxm, max_nclosure, dimension_only;
int isx, *nb, *ng; 
{ 
int nbs, nbk, nbr, itx, icent;
register int nbq, iklm;

/* Coordinate of center of the mask: */
icent = nxm/2;
 
/* First condition: input point has to be accessible */
  if(mask[isx + icent] <= 0.) return(-1);

/* If so, record the new point of the uv coverage (spectral list): */
 (*nb)++;
 ixy_1[*nb] = isx;
 nbcouv[isx] = *nb;

/* Searching for the couples associated with the point NBS=NB
* Generating the bispectral list and building the rows of the A matrix:
*/
 nbs = *nb;
 
/* Loop on all the possible points (Q): */
 iklm = 3 * (*ng);
 for( nbq = 1; nbq < nbs; nbq++)
  { 
/* JLP 94: add an exit test when maximum number of closure relations
has been found (to simulate Knox-Thompson and/or accelerate computations...) */ 
   if((*ng - ngt[(*nb) -1]) == max_nclosure) break;

/* Coordinates of the vector T = S - Q */
   itx = isx - ixy_1[nbq];
 
/* Work within the segment of length IRS, so we can a priori reject
* the points outside the window [-IRS,+IRS]:
*/
   if(itx >= -isx && itx <= isx)
      {
/* Case number 1 only for 1D case (which could be : k=t, l=q, k+l=s) */

/* t should be accessible too: */
            if(mask[itx + icent] > 0.)
            {
              nbk = nbcouv[itx];
 
/* We select this couple (U,V) if the vector NBK is in [0,NBQ] */
              if( nbk != 0 && nbk <= nbq)
                 {
/* Add new k,l,m coordinates if more than dimension is wanted */
                 if(!dimension_only)
                   {
                   klm[iklm] = nbk; 
                   iklm++;
                   klm[iklm] = nbq; 
                   iklm++;
                   klm[iklm] = nbs;
                   iklm++;
                   }
                 (*ng)++;
                 }
          }
      else
          { 
/* Case number 2 (which could be : r=-t, s=s, r+s=m=q) */
/* r should be accessible too: */
            if(mask[-itx + icent] > 0.)
            {
             nbr = nbcouv[-itx];
/* We select this couple (R,S) if the vector NBR is in [0,NBS] */
              if( nbr != 0 && nbr <= nbs)
                  {
/* Add new k,l,m coordinates if more than dimension is wanted */
                  if(!dimension_only)
                     {
                     klm[iklm] = nbr; 
                     iklm++;
                     klm[iklm] = nbs; 
                     iklm++;
                     klm[iklm] = nbq;
                     iklm++;
                     }
                  (*ng)++;
                  }
            }
/* Nota: we can only have L=NBS or M=NBS (never K=NBS) */
          }
      } 

/* End of loop on nbq */
}
 
/* NGT(NB) is the number of the last U,V couple of the group NB=NBS=S: */
   ngt[nbs] = *ng;

 return(0);
}
